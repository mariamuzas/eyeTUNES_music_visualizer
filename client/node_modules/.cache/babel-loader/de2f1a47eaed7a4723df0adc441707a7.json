{"ast":null,"code":"import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\n\nexport class Source extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    /**\n     * Sources have no inputs\n     */\n\n    this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n\n    this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n\n    this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n\n    this._syncedStart = noOp;\n    this._syncedStop = noOp;\n    this._state.memory = 100;\n    this._state.increasing = true;\n    this._volume = this.output = new Volume({\n      context: this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.onstop = options.onstop;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      onstop: noOp,\n      volume: 0\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n   * \tplayer.start();\n   * \tconsole.log(player.state);\n   * }).toDestination();\n   */\n\n\n  get state() {\n    if (this._synced) {\n      if (this.context.transport.state === \"started\") {\n        return this._state.getValueAtTime(this.context.transport.seconds);\n      } else {\n        return \"stopped\";\n      }\n    } else {\n      return this._state.getValueAtTime(this.now());\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // mute the output\n   * osc.mute = true;\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n  /**\n   * Ensure that the scheduled time is not before the current time.\n   * Should only be used when scheduled unsynced.\n   */\n\n\n  _clampToCurrentTime(time) {\n    if (this._synced) {\n      return time;\n    } else {\n      return Math.max(time, this.context.currentTime);\n    }\n  }\n  /**\n   * Start the source at the specified time. If no time is given,\n   * start the source now.\n   * @param  time When the source should be started.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n   */\n\n\n  start(time, offset, duration) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime); // if it's started, stop it and restart it\n\n    if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n      // time should be strictly greater than the previous start time\n      assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      this.log(\"restart\", computedTime);\n      this.restart(computedTime, offset, duration);\n    } else {\n      this.log(\"start\", computedTime);\n\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      if (this._synced) {\n        // add the offset time to the event\n        const event = this._state.get(computedTime);\n\n        if (event) {\n          event.offset = this.toSeconds(defaultArg(offset, 0));\n          event.duration = duration ? this.toSeconds(duration) : undefined;\n        }\n\n        const sched = this.context.transport.schedule(t => {\n          this._start(t, offset, duration);\n        }, computedTime);\n\n        this._scheduled.push(sched); // if the transport is already started\n        // and the time is greater than where the transport is\n\n\n        if (this.context.transport.state === \"started\" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n          this._syncedStart(this.now(), this.context.transport.seconds);\n        }\n      } else {\n        assertContextRunning(this.context);\n\n        this._start(computedTime, offset, duration);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Stop the source at the specified time. If no time is given,\n   * stop the source now.\n   * @param  time When the source should be stopped.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start();\n   * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n   */\n\n\n  stop(time) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n      this.log(\"stop\", computedTime);\n\n      if (!this._synced) {\n        this._stop(computedTime);\n      } else {\n        const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\n        this._scheduled.push(sched);\n      }\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"stopped\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Restart the source.\n   */\n\n\n  restart(time, offset, duration) {\n    time = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(time) === \"started\") {\n      this._state.cancel(time);\n\n      this._restart(time, offset, duration);\n    }\n\n    return this;\n  }\n  /**\n   * Sync the source to the Transport so that all subsequent\n   * calls to `start` and `stop` are synced to the TransportTime\n   * instead of the AudioContext time.\n   *\n   * @example\n   * const osc = new Tone.Oscillator().toDestination();\n   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n   * osc.sync().start(0).stop(0.3);\n   * // start the transport.\n   * Tone.Transport.start();\n   * // set it to loop once a second\n   * Tone.Transport.loop = true;\n   * Tone.Transport.loopEnd = 1;\n   */\n\n\n  sync() {\n    if (!this._synced) {\n      this._synced = true;\n\n      this._syncedStart = (time, offset) => {\n        if (offset > 0) {\n          // get the playback state at that time\n          const stateEvent = this._state.get(offset); // listen for start events which may occur in the middle of the sync'ed time\n\n\n          if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n            // get the offset\n            const startOffset = offset - this.toSeconds(stateEvent.time);\n            let duration;\n\n            if (stateEvent.duration) {\n              duration = this.toSeconds(stateEvent.duration) - startOffset;\n            }\n\n            this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n          }\n        }\n      };\n\n      this._syncedStop = time => {\n        const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\n        if (this._state.getValueAtTime(seconds) === \"started\") {\n          this._stop(time);\n        }\n      };\n\n      this.context.transport.on(\"start\", this._syncedStart);\n      this.context.transport.on(\"loopStart\", this._syncedStart);\n      this.context.transport.on(\"stop\", this._syncedStop);\n      this.context.transport.on(\"pause\", this._syncedStop);\n      this.context.transport.on(\"loopEnd\", this._syncedStop);\n    }\n\n    return this;\n  }\n  /**\n   * Unsync the source to the Transport. See Source.sync\n   */\n\n\n  unsync() {\n    if (this._synced) {\n      this.context.transport.off(\"stop\", this._syncedStop);\n      this.context.transport.off(\"pause\", this._syncedStop);\n      this.context.transport.off(\"loopEnd\", this._syncedStop);\n      this.context.transport.off(\"start\", this._syncedStart);\n      this.context.transport.off(\"loopStart\", this._syncedStart);\n    }\n\n    this._synced = false; // clear all of the scheduled ids\n\n    this._scheduled.forEach(id => this.context.transport.clear(id));\n\n    this._scheduled = [];\n\n    this._state.cancel(0); // stop it also\n\n\n    this._stop(0);\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.onstop = noOp;\n    this.unsync();\n\n    this._volume.dispose();\n\n    this._state.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/source/Source.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport class Source extends ToneAudioNode {\n    constructor(options) {\n        super(options);\n        /**\n         * Sources have no inputs\n         */\n        this.input = undefined;\n        /**\n         * Keep track of the scheduled state.\n         */\n        this._state = new StateTimeline(\"stopped\");\n        /**\n         * The synced `start` callback function from the transport\n         */\n        this._synced = false;\n        /**\n         * Keep track of all of the scheduled event ids\n         */\n        this._scheduled = [];\n        /**\n         * Placeholder functions for syncing/unsyncing to transport\n         */\n        this._syncedStart = noOp;\n        this._syncedStop = noOp;\n        this._state.memory = 100;\n        this._state.increasing = true;\n        this._volume = this.output = new Volume({\n            context: this.context,\n            mute: options.mute,\n            volume: options.volume,\n        });\n        this.volume = this._volume.volume;\n        readOnly(this, \"volume\");\n        this.onstop = options.onstop;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            onstop: noOp,\n            volume: 0,\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n     * \tplayer.start();\n     * \tconsole.log(player.state);\n     * }).toDestination();\n     */\n    get state() {\n        if (this._synced) {\n            if (this.context.transport.state === \"started\") {\n                return this._state.getValueAtTime(this.context.transport.seconds);\n            }\n            else {\n                return \"stopped\";\n            }\n        }\n        else {\n            return this._state.getValueAtTime(this.now());\n        }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // mute the output\n     * osc.mute = true;\n     */\n    get mute() {\n        return this._volume.mute;\n    }\n    set mute(mute) {\n        this._volume.mute = mute;\n    }\n    /**\n     * Ensure that the scheduled time is not before the current time.\n     * Should only be used when scheduled unsynced.\n     */\n    _clampToCurrentTime(time) {\n        if (this._synced) {\n            return time;\n        }\n        else {\n            return Math.max(time, this.context.currentTime);\n        }\n    }\n    /**\n     * Start the source at the specified time. If no time is given,\n     * start the source now.\n     * @param  time When the source should be started.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n     */\n    start(time, offset, duration) {\n        let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n        computedTime = this._clampToCurrentTime(computedTime);\n        // if it's started, stop it and restart it\n        if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n            // time should be strictly greater than the previous start time\n            assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n            this._state.cancel(computedTime);\n            this._state.setStateAtTime(\"started\", computedTime);\n            this.log(\"restart\", computedTime);\n            this.restart(computedTime, offset, duration);\n        }\n        else {\n            this.log(\"start\", computedTime);\n            this._state.setStateAtTime(\"started\", computedTime);\n            if (this._synced) {\n                // add the offset time to the event\n                const event = this._state.get(computedTime);\n                if (event) {\n                    event.offset = this.toSeconds(defaultArg(offset, 0));\n                    event.duration = duration ? this.toSeconds(duration) : undefined;\n                }\n                const sched = this.context.transport.schedule(t => {\n                    this._start(t, offset, duration);\n                }, computedTime);\n                this._scheduled.push(sched);\n                // if the transport is already started\n                // and the time is greater than where the transport is\n                if (this.context.transport.state === \"started\" &&\n                    this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n                    this._syncedStart(this.now(), this.context.transport.seconds);\n                }\n            }\n            else {\n                assertContextRunning(this.context);\n                this._start(computedTime, offset, duration);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the source at the specified time. If no time is given,\n     * stop the source now.\n     * @param  time When the source should be stopped.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start();\n     * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n     */\n    stop(time) {\n        let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n        computedTime = this._clampToCurrentTime(computedTime);\n        if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n            this.log(\"stop\", computedTime);\n            if (!this._synced) {\n                this._stop(computedTime);\n            }\n            else {\n                const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n                this._scheduled.push(sched);\n            }\n            this._state.cancel(computedTime);\n            this._state.setStateAtTime(\"stopped\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Restart the source.\n     */\n    restart(time, offset, duration) {\n        time = this.toSeconds(time);\n        if (this._state.getValueAtTime(time) === \"started\") {\n            this._state.cancel(time);\n            this._restart(time, offset, duration);\n        }\n        return this;\n    }\n    /**\n     * Sync the source to the Transport so that all subsequent\n     * calls to `start` and `stop` are synced to the TransportTime\n     * instead of the AudioContext time.\n     *\n     * @example\n     * const osc = new Tone.Oscillator().toDestination();\n     * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n     * osc.sync().start(0).stop(0.3);\n     * // start the transport.\n     * Tone.Transport.start();\n     * // set it to loop once a second\n     * Tone.Transport.loop = true;\n     * Tone.Transport.loopEnd = 1;\n     */\n    sync() {\n        if (!this._synced) {\n            this._synced = true;\n            this._syncedStart = (time, offset) => {\n                if (offset > 0) {\n                    // get the playback state at that time\n                    const stateEvent = this._state.get(offset);\n                    // listen for start events which may occur in the middle of the sync'ed time\n                    if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n                        // get the offset\n                        const startOffset = offset - this.toSeconds(stateEvent.time);\n                        let duration;\n                        if (stateEvent.duration) {\n                            duration = this.toSeconds(stateEvent.duration) - startOffset;\n                        }\n                        this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n                    }\n                }\n            };\n            this._syncedStop = time => {\n                const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n                if (this._state.getValueAtTime(seconds) === \"started\") {\n                    this._stop(time);\n                }\n            };\n            this.context.transport.on(\"start\", this._syncedStart);\n            this.context.transport.on(\"loopStart\", this._syncedStart);\n            this.context.transport.on(\"stop\", this._syncedStop);\n            this.context.transport.on(\"pause\", this._syncedStop);\n            this.context.transport.on(\"loopEnd\", this._syncedStop);\n        }\n        return this;\n    }\n    /**\n     * Unsync the source to the Transport. See Source.sync\n     */\n    unsync() {\n        if (this._synced) {\n            this.context.transport.off(\"stop\", this._syncedStop);\n            this.context.transport.off(\"pause\", this._syncedStop);\n            this.context.transport.off(\"loopEnd\", this._syncedStop);\n            this.context.transport.off(\"start\", this._syncedStart);\n            this.context.transport.off(\"loopStart\", this._syncedStart);\n        }\n        this._synced = false;\n        // clear all of the scheduled ids\n        this._scheduled.forEach(id => this.context.transport.clear(id));\n        this._scheduled = [];\n        this._state.cancel(0);\n        // stop it also\n        this._stop(0);\n        return this;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.onstop = noOp;\n        this.unsync();\n        this._volume.dispose();\n        this._state.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Source.js.map"]},"metadata":{},"sourceType":"module"}