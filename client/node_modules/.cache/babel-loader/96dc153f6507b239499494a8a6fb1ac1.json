{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\n\nexport class OfflineContext extends Context {\n  constructor() {\n    super({\n      clockSource: \"offline\",\n      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n      lookAhead: 0,\n      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]\n    });\n    this.name = \"OfflineContext\";\n    /**\n     * An artificial clock source\n     */\n\n    this._currentTime = 0;\n    this.isOffline = true;\n    this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];\n  }\n  /**\n   * Override the now method to point to the internal clock time\n   */\n\n\n  now() {\n    return this._currentTime;\n  }\n  /**\n   * Same as this.now()\n   */\n\n\n  get currentTime() {\n    return this._currentTime;\n  }\n  /**\n   * Render just the clock portion of the audio context.\n   */\n\n\n  _renderClock(asynchronous) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let index = 0;\n\n      while (this._duration - this._currentTime >= 0) {\n        // invoke all the callbacks on that time\n        this.emit(\"tick\"); // increment the clock in block-sized chunks\n\n        this._currentTime += 128 / this.sampleRate; // yield once a second of audio\n\n        index++;\n        const yieldEvery = Math.floor(this.sampleRate / 128);\n\n        if (asynchronous && index % yieldEvery === 0) {\n          yield new Promise(done => setTimeout(done, 1));\n        }\n      }\n    });\n  }\n  /**\n   * Render the output of the OfflineContext\n   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n   */\n\n\n  render(asynchronous = true) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.workletsAreReady();\n      yield this._renderClock(asynchronous);\n      const buffer = yield this._context.startRendering();\n      return new ToneAudioBuffer(buffer);\n    });\n  }\n  /**\n   * Close the context\n   */\n\n\n  close() {\n    return Promise.resolve();\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/core/context/OfflineContext.ts"],"names":[],"mappings":";AAAA,SAAS,yBAAT,QAA0C,yBAA1C;AACA,SAAS,OAAT,QAAwB,oBAAxB;AAEA,SAAS,qBAAT,QAAsC,2BAAtC;AACA,SAAS,eAAT,QAAgC,mBAAhC;AAEA;;;;;;;;;;AAUG;;AACH,OAAM,MAAO,cAAP,SAA8B,OAA9B,CAAqC;AAgC1C,EAAA,WAAA,GAAA;AAEC,UAAM;AACL,MAAA,WAAW,EAAE,SADR;AAEL,MAAA,OAAO,EAAE,qBAAqB,CAAC,SAAS,CAAC,CAAD,CAAV,CAArB,GACR,SAAS,CAAC,CAAD,CADD,GACO,yBAAyB,CAAC,SAAS,CAAC,CAAD,CAAV,EAAe,SAAS,CAAC,CAAD,CAAT,GAAe,SAAS,CAAC,CAAD,CAAvC,EAA4C,SAAS,CAAC,CAAD,CAArD,CAHpC;AAIL,MAAA,SAAS,EAAE,CAJN;AAKL,MAAA,cAAc,EAAE,qBAAqB,CAAC,SAAS,CAAC,CAAD,CAAV,CAArB,GACf,MAAM,SAAS,CAAC,CAAD,CAAT,CAAa,UADJ,GACiB,MAAM,SAAS,CAAC,CAAD;AAN3C,KAAN;AAhCQ,SAAA,IAAA,GAAe,gBAAf;AAOT;;AAEG;;AACK,SAAA,YAAA,GAAwB,CAAxB;AAOC,SAAA,SAAA,GAAqB,IAArB;AAwBR,SAAK,SAAL,GAAiB,qBAAqB,CAAC,SAAS,CAAC,CAAD,CAAV,CAArB,GAChB,SAAS,CAAC,CAAD,CAAT,CAAa,MAAb,GAAsB,SAAS,CAAC,CAAD,CAAT,CAAa,UADnB,GACgC,SAAS,CAAC,CAAD,CAD1D;AAEA;AAED;;AAEG;;;AACH,EAAA,GAAG,GAAA;AACF,WAAO,KAAK,YAAZ;AACA;AAED;;AAEG;;;AACH,MAAI,WAAJ,GAAe;AACd,WAAO,KAAK,YAAZ;AACA;AAED;;AAEG;;;AACW,EAAA,YAAY,CAAC,YAAD,EAAsB;;AAC/C,UAAI,KAAK,GAAG,CAAZ;;AACA,aAAO,KAAK,SAAL,GAAiB,KAAK,YAAtB,IAAsC,CAA7C,EAAgD;AAE/C;AACA,aAAK,IAAL,CAAU,MAAV,EAH+C,CAK/C;;AACA,aAAK,YAAL,IAAqB,MAAM,KAAK,UAAhC,CAN+C,CAQ/C;;AACA,QAAA,KAAK;AACL,cAAM,UAAU,GAAG,IAAI,CAAC,KAAL,CAAW,KAAK,UAAL,GAAkB,GAA7B,CAAnB;;AACA,YAAI,YAAY,IAAI,KAAK,GAAG,UAAR,KAAuB,CAA3C,EAA8C;AAC7C,gBAAM,IAAI,OAAJ,CAAY,IAAI,IAAI,UAAU,CAAC,IAAD,EAAO,CAAP,CAA9B,CAAN;AACA;AACD;AACD,K;AAAA;AAED;;;AAGG;;;AACG,EAAA,MAAM,CAAC,YAAY,GAAG,IAAhB,EAAoB;;AAC/B,YAAM,KAAK,gBAAL,EAAN;AACA,YAAM,KAAK,YAAL,CAAkB,YAAlB,CAAN;AACA,YAAM,MAAM,GAAG,MAAM,KAAK,QAAL,CAAc,cAAd,EAArB;AACA,aAAO,IAAI,eAAJ,CAAoB,MAApB,CAAP;AACA,K;AAAA;AAED;;AAEG;;;AACH,EAAA,KAAK,GAAA;AACJ,WAAO,OAAO,CAAC,OAAR,EAAP;AACA;;AAnGyC","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n    constructor() {\n        super({\n            clockSource: \"offline\",\n            context: isOfflineAudioContext(arguments[0]) ?\n                arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n            lookAhead: 0,\n            updateInterval: isOfflineAudioContext(arguments[0]) ?\n                128 / arguments[0].sampleRate : 128 / arguments[2],\n        });\n        this.name = \"OfflineContext\";\n        /**\n         * An artificial clock source\n         */\n        this._currentTime = 0;\n        this.isOffline = true;\n        this._duration = isOfflineAudioContext(arguments[0]) ?\n            arguments[0].length / arguments[0].sampleRate : arguments[1];\n    }\n    /**\n     * Override the now method to point to the internal clock time\n     */\n    now() {\n        return this._currentTime;\n    }\n    /**\n     * Same as this.now()\n     */\n    get currentTime() {\n        return this._currentTime;\n    }\n    /**\n     * Render just the clock portion of the audio context.\n     */\n    _renderClock(asynchronous) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let index = 0;\n            while (this._duration - this._currentTime >= 0) {\n                // invoke all the callbacks on that time\n                this.emit(\"tick\");\n                // increment the clock in block-sized chunks\n                this._currentTime += 128 / this.sampleRate;\n                // yield once a second of audio\n                index++;\n                const yieldEvery = Math.floor(this.sampleRate / 128);\n                if (asynchronous && index % yieldEvery === 0) {\n                    yield new Promise(done => setTimeout(done, 1));\n                }\n            }\n        });\n    }\n    /**\n     * Render the output of the OfflineContext\n     * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n     */\n    render(asynchronous = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.workletsAreReady();\n            yield this._renderClock(asynchronous);\n            const buffer = yield this._context.startRendering();\n            return new ToneAudioBuffer(buffer);\n        });\n    }\n    /**\n     * Close the context\n     */\n    close() {\n        return Promise.resolve();\n    }\n}\n//# sourceMappingURL=OfflineContext.js.map"]},"metadata":{},"sourceType":"module"}