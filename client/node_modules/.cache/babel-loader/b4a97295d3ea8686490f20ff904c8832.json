{"ast":null,"code":"import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n  return class OfflineAudioContext extends baseAudioContextConstructor {\n    constructor(a, b, c) {\n      let options;\n\n      if (typeof a === 'number' && b !== undefined && c !== undefined) {\n        options = {\n          length: b,\n          numberOfChannels: a,\n          sampleRate: c\n        };\n      } else if (typeof a === 'object') {\n        options = a;\n      } else {\n        throw new Error('The given parameters are not valid.');\n      }\n\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n\n      if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n        nativeOfflineAudioContext.addEventListener('statechange', (() => {\n          let i = 0;\n\n          const delayStateChangeEvent = event => {\n            if (this._state === 'running') {\n              if (i > 0) {\n                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                event.stopImmediatePropagation();\n\n                this._waitForThePromiseToSettle(event);\n              } else {\n                i += 1;\n              }\n            }\n          };\n\n          return delayStateChangeEvent;\n        })());\n      }\n\n      super(nativeOfflineAudioContext, numberOfChannels);\n      this._length = length;\n      this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n      this._state = null;\n    }\n\n    get length() {\n      // Bug #17: Safari does not yet expose the length.\n      if (this._nativeOfflineAudioContext.length === undefined) {\n        return this._length;\n      }\n\n      return this._nativeOfflineAudioContext.length;\n    }\n\n    get state() {\n      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n    }\n\n    startRendering() {\n      /*\n       * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n       * the state of the nativeOfflineAudioContext might no transition to running immediately.\n       */\n      if (this._state === 'running') {\n        return Promise.reject(createInvalidStateError());\n      }\n\n      this._state = 'running';\n      return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n        this._state = null;\n        deactivateAudioGraph(this);\n      });\n    }\n\n    _waitForThePromiseToSettle(event) {\n      if (this._state === null) {\n        this._nativeOfflineAudioContext.dispatchEvent(event);\n      } else {\n        setTimeout(() => this._waitForThePromiseToSettle(event));\n      }\n    }\n\n  };\n};","map":{"version":3,"sources":["../../../src/factories/offline-audio-context-constructor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor {\n        constructor(a, b, c) {\n            let options;\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            }\n            else if (typeof a === 'object') {\n                options = a;\n            }\n            else {\n                throw new Error('The given parameters are not valid.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n                deactivateAudioGraph(this);\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=offline-audio-context-constructor.js.map"]},"metadata":{},"sourceType":"module"}