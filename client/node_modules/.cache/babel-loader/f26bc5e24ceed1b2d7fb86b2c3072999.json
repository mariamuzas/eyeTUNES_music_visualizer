{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\n\nexport class Reverb extends Effect {\n  constructor() {\n    super(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n    this.name = \"Reverb\";\n    /**\n     * Convolver node\n     */\n\n    this._convolver = this.context.createConvolver();\n    /**\n     * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n     * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n     * before the IR is generated with the latest values.\n     */\n\n    this.ready = Promise.resolve();\n    const options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n    this._decay = options.decay;\n    this._preDelay = options.preDelay;\n    this.generate();\n    this.connectEffect(this._convolver);\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      decay: 1.5,\n      preDelay: 0.01\n    });\n  }\n  /**\n   * The duration of the reverb.\n   */\n\n\n  get decay() {\n    return this._decay;\n  }\n\n  set decay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0.001);\n    this._decay = time;\n    this.generate();\n  }\n  /**\n   * The amount of time before the reverb is fully ramped in.\n   */\n\n\n  get preDelay() {\n    return this._preDelay;\n  }\n\n  set preDelay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0);\n    this._preDelay = time;\n    this.generate();\n  }\n  /**\n   * Generate the Impulse Response. Returns a promise while the IR is being generated.\n   * @return Promise which returns this object.\n   */\n\n\n  generate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const previousReady = this.ready; // create a noise burst which decays over the duration in each channel\n\n      const context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n      const noiseL = new Noise({\n        context\n      });\n      const noiseR = new Noise({\n        context\n      });\n      const merge = new Merge({\n        context\n      });\n      noiseL.connect(merge, 0, 0);\n      noiseR.connect(merge, 0, 1);\n      const gainNode = new Gain({\n        context\n      }).toDestination();\n      merge.connect(gainNode);\n      noiseL.start(0);\n      noiseR.start(0); // predelay\n\n      gainNode.gain.setValueAtTime(0, 0);\n      gainNode.gain.setValueAtTime(1, this._preDelay); // decay\n\n      gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay); // render the buffer\n\n      const renderPromise = context.render();\n      this.ready = renderPromise.then(noOp); // wait for the previous `ready` to resolve\n\n      yield previousReady; // set the buffer\n\n      this._convolver.buffer = (yield renderPromise).get();\n      return this;\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._convolver.disconnect();\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/effect/Reverb.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\nexport class Reverb extends Effect {\n    constructor() {\n        super(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n        this.name = \"Reverb\";\n        /**\n         * Convolver node\n         */\n        this._convolver = this.context.createConvolver();\n        /**\n         * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n         * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n         * before the IR is generated with the latest values.\n         */\n        this.ready = Promise.resolve();\n        const options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n        this._decay = options.decay;\n        this._preDelay = options.preDelay;\n        this.generate();\n        this.connectEffect(this._convolver);\n    }\n    static getDefaults() {\n        return Object.assign(Effect.getDefaults(), {\n            decay: 1.5,\n            preDelay: 0.01,\n        });\n    }\n    /**\n     * The duration of the reverb.\n     */\n    get decay() {\n        return this._decay;\n    }\n    set decay(time) {\n        time = this.toSeconds(time);\n        assertRange(time, 0.001);\n        this._decay = time;\n        this.generate();\n    }\n    /**\n     * The amount of time before the reverb is fully ramped in.\n     */\n    get preDelay() {\n        return this._preDelay;\n    }\n    set preDelay(time) {\n        time = this.toSeconds(time);\n        assertRange(time, 0);\n        this._preDelay = time;\n        this.generate();\n    }\n    /**\n     * Generate the Impulse Response. Returns a promise while the IR is being generated.\n     * @return Promise which returns this object.\n     */\n    generate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const previousReady = this.ready;\n            // create a noise burst which decays over the duration in each channel\n            const context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n            const noiseL = new Noise({ context });\n            const noiseR = new Noise({ context });\n            const merge = new Merge({ context });\n            noiseL.connect(merge, 0, 0);\n            noiseR.connect(merge, 0, 1);\n            const gainNode = new Gain({ context }).toDestination();\n            merge.connect(gainNode);\n            noiseL.start(0);\n            noiseR.start(0);\n            // predelay\n            gainNode.gain.setValueAtTime(0, 0);\n            gainNode.gain.setValueAtTime(1, this._preDelay);\n            // decay\n            gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n            // render the buffer\n            const renderPromise = context.render();\n            this.ready = renderPromise.then(noOp);\n            // wait for the previous `ready` to resolve\n            yield previousReady;\n            // set the buffer\n            this._convolver.buffer = (yield renderPromise).get();\n            return this;\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._convolver.disconnect();\n        return this;\n    }\n}\n//# sourceMappingURL=Reverb.js.map"]},"metadata":{},"sourceType":"module"}