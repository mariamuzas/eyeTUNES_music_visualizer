{"ast":null,"code":"/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n  constructor(callback, type, updateInterval) {\n    this._callback = callback;\n    this._type = type;\n    this._updateInterval = updateInterval; // create the clock source for the first time\n\n    this._createClock();\n  }\n  /**\n   * Generate a web worker\n   */\n\n\n  _createWorker() {\n    const blob = new Blob([\n    /* javascript */\n    `\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`], {\n      type: \"text/javascript\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    const worker = new Worker(blobUrl);\n    worker.onmessage = this._callback.bind(this);\n    this._worker = worker;\n  }\n  /**\n   * Create a timeout loop\n   */\n\n\n  _createTimeout() {\n    this._timeout = setTimeout(() => {\n      this._createTimeout();\n\n      this._callback();\n    }, this._updateInterval * 1000);\n  }\n  /**\n   * Create the clock source.\n   */\n\n\n  _createClock() {\n    if (this._type === \"worker\") {\n      try {\n        this._createWorker();\n      } catch (e) {\n        // workers not supported, fallback to timeout\n        this._type = \"timeout\";\n\n        this._createClock();\n      }\n    } else if (this._type === \"timeout\") {\n      this._createTimeout();\n    }\n  }\n  /**\n   * Clean up the current clock source\n   */\n\n\n  _disposeClock() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = 0;\n    }\n\n    if (this._worker) {\n      this._worker.terminate();\n\n      this._worker.onmessage = null;\n    }\n  }\n  /**\n   * The rate in seconds the ticker will update\n   */\n\n\n  get updateInterval() {\n    return this._updateInterval;\n  }\n\n  set updateInterval(interval) {\n    this._updateInterval = Math.max(interval, 128 / 44100);\n\n    if (this._type === \"worker\") {\n      this._worker.postMessage(Math.max(interval * 1000, 1));\n    }\n  }\n  /**\n   * The type of the ticker, either a worker or a timeout\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._disposeClock();\n\n    this._type = type;\n\n    this._createClock();\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    this._disposeClock();\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/core/clock/Ticker.ts"],"names":[],"mappings":"AAIA;;;AAGG;AACH,OAAM,MAAO,MAAP,CAAa;AA2BlB,EAAA,WAAA,CAAY,QAAZ,EAAkC,IAAlC,EAA2D,cAA3D,EAAkF;AAEjF,SAAK,SAAL,GAAiB,QAAjB;AACA,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,eAAL,GAAuB,cAAvB,CAJiF,CAMjF;;AACA,SAAK,YAAL;AACA;AAED;;AAEG;;;AACK,EAAA,aAAa,GAAA;AAEpB,UAAM,IAAI,GAAG,IAAI,IAAJ,CAAS;AACrB;AAAgB;;wBAEK,CAAC,KAAK,eAAL,GAAuB,IAAxB,EAA8B,OAA9B,CAAsC,CAAtC,CAAwC;;;;;;;;;;;;;AAa5D,IAhBoB,CAAT,EAiBV;AAAE,MAAA,IAAI,EAAE;AAAR,KAjBU,CAAb;AAkBA,UAAM,OAAO,GAAG,GAAG,CAAC,eAAJ,CAAoB,IAApB,CAAhB;AACA,UAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,OAAX,CAAf;AAEA,IAAA,MAAM,CAAC,SAAP,GAAmB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CAAnB;AAEA,SAAK,OAAL,GAAe,MAAf;AACA;AAED;;AAEG;;;AACK,EAAA,cAAc,GAAA;AACrB,SAAK,QAAL,GAAgB,UAAU,CAAC,MAAK;AAC/B,WAAK,cAAL;;AACA,WAAK,SAAL;AACA,KAHyB,EAGvB,KAAK,eAAL,GAAuB,IAHA,CAA1B;AAIA;AAED;;AAEG;;;AACK,EAAA,YAAY,GAAA;AACnB,QAAI,KAAK,KAAL,KAAe,QAAnB,EAA6B;AAC5B,UAAI;AACH,aAAK,aAAL;AACA,OAFD,CAEE,OAAO,CAAP,EAAU;AACX;AACA,aAAK,KAAL,GAAa,SAAb;;AACA,aAAK,YAAL;AACA;AACD,KARD,MAQO,IAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AACpC,WAAK,cAAL;AACA;AACD;AAED;;AAEG;;;AACK,EAAA,aAAa,GAAA;AACpB,QAAI,KAAK,QAAT,EAAmB;AAClB,MAAA,YAAY,CAAC,KAAK,QAAN,CAAZ;AACA,WAAK,QAAL,GAAgB,CAAhB;AACA;;AACD,QAAI,KAAK,OAAT,EAAkB;AACjB,WAAK,OAAL,CAAa,SAAb;;AACA,WAAK,OAAL,CAAa,SAAb,GAAyB,IAAzB;AACA;AACD;AAED;;AAEG;;;AACH,MAAI,cAAJ,GAAkB;AACjB,WAAO,KAAK,eAAZ;AACA;;AACD,MAAI,cAAJ,CAAmB,QAAnB,EAAoC;AACnC,SAAK,eAAL,GAAuB,IAAI,CAAC,GAAL,CAAS,QAAT,EAAmB,MAAM,KAAzB,CAAvB;;AACA,QAAI,KAAK,KAAL,KAAe,QAAnB,EAA6B;AAC5B,WAAK,OAAL,CAAa,WAAb,CAAyB,IAAI,CAAC,GAAL,CAAS,QAAQ,GAAG,IAApB,EAA0B,CAA1B,CAAzB;AACA;AACD;AAED;;AAEG;;;AACH,MAAI,IAAJ,GAAQ;AACP,WAAO,KAAK,KAAZ;AACA;;AACD,MAAI,IAAJ,CAAS,IAAT,EAAgC;AAC/B,SAAK,aAAL;;AACA,SAAK,KAAL,GAAa,IAAb;;AACA,SAAK,YAAL;AACA;AAED;;AAEG;;;AACH,EAAA,OAAO,GAAA;AACN,SAAK,aAAL;AACA;;AA3IiB","sourceRoot":"","sourcesContent":["/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n    constructor(callback, type, updateInterval) {\n        this._callback = callback;\n        this._type = type;\n        this._updateInterval = updateInterval;\n        // create the clock source for the first time\n        this._createClock();\n    }\n    /**\n     * Generate a web worker\n     */\n    _createWorker() {\n        const blob = new Blob([\n            /* javascript */ `\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`\n        ], { type: \"text/javascript\" });\n        const blobUrl = URL.createObjectURL(blob);\n        const worker = new Worker(blobUrl);\n        worker.onmessage = this._callback.bind(this);\n        this._worker = worker;\n    }\n    /**\n     * Create a timeout loop\n     */\n    _createTimeout() {\n        this._timeout = setTimeout(() => {\n            this._createTimeout();\n            this._callback();\n        }, this._updateInterval * 1000);\n    }\n    /**\n     * Create the clock source.\n     */\n    _createClock() {\n        if (this._type === \"worker\") {\n            try {\n                this._createWorker();\n            }\n            catch (e) {\n                // workers not supported, fallback to timeout\n                this._type = \"timeout\";\n                this._createClock();\n            }\n        }\n        else if (this._type === \"timeout\") {\n            this._createTimeout();\n        }\n    }\n    /**\n     * Clean up the current clock source\n     */\n    _disposeClock() {\n        if (this._timeout) {\n            clearTimeout(this._timeout);\n            this._timeout = 0;\n        }\n        if (this._worker) {\n            this._worker.terminate();\n            this._worker.onmessage = null;\n        }\n    }\n    /**\n     * The rate in seconds the ticker will update\n     */\n    get updateInterval() {\n        return this._updateInterval;\n    }\n    set updateInterval(interval) {\n        this._updateInterval = Math.max(interval, 128 / 44100);\n        if (this._type === \"worker\") {\n            this._worker.postMessage(Math.max(interval * 1000, 1));\n        }\n    }\n    /**\n     * The type of the ticker, either a worker or a timeout\n     */\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        this._disposeClock();\n        this._type = type;\n        this._createClock();\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        this._disposeClock();\n    }\n}\n//# sourceMappingURL=Ticker.js.map"]},"metadata":{},"sourceType":"module"}