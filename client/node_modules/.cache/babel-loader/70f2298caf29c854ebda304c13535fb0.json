{"ast":null,"code":"import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\n\nexport class ToneOscillatorNode extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"ToneOscillatorNode\";\n    /**\n     * The oscillator\n     */\n\n    this._oscillator = this.context.createOscillator();\n    this._internalChannels = [this._oscillator];\n    const options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    connect(this._oscillator, this._gainNode);\n    this.type = options.type;\n    this.frequency = new Param({\n      context: this.context,\n      param: this._oscillator.frequency,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Param({\n      context: this.context,\n      param: this._oscillator.detune,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, [\"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      type: \"sine\"\n    });\n  }\n  /**\n   * Start the oscillator node at the given time\n   * @param  time When to start the oscillator\n   */\n\n\n  start(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    this._startGain(computedTime);\n\n    this._oscillator.start(computedTime);\n\n    return this;\n  }\n\n  _stopSource(time) {\n    this._oscillator.stop(time);\n  }\n  /**\n   * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n   */\n\n\n  setPeriodicWave(periodicWave) {\n    this._oscillator.setPeriodicWave(periodicWave);\n\n    return this;\n  }\n  /**\n   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n   */\n\n\n  get type() {\n    return this._oscillator.type;\n  }\n\n  set type(type) {\n    this._oscillator.type = type;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this.state === \"started\") {\n      this.stop();\n    }\n\n    this._oscillator.disconnect();\n\n    this.frequency.dispose();\n    this.detune.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/source/oscillator/ToneOscillatorNode.ts"],"names":[],"mappings":"AAAA,SAAS,OAAT,QAAwB,kCAAxB;AACA,SAAS,KAAT,QAAsB,0BAAtB;AAEA,SAAS,oBAAT,QAAqC,0BAArC;AACA,SAAS,aAAT,QAAoD,kBAApD;AACA,SAAS,QAAT,QAAyB,2BAAzB;AAQA;;;;;AAKG;;AACH,OAAM,MAAO,kBAAP,SAAkC,aAAlC,CAA0E;AA6B/E,EAAA,WAAA,GAAA;AAEC,UAAM,oBAAoB,CAAC,kBAAkB,CAAC,WAAnB,EAAD,EAAmC,SAAnC,EAA8C,CAAC,WAAD,EAAc,MAAd,CAA9C,CAA1B;AA7BQ,SAAA,IAAA,GAAe,oBAAf;AAET;;AAEG;;AACK,SAAA,WAAA,GAAc,KAAK,OAAL,CAAa,gBAAb,EAAd;AACE,SAAA,iBAAA,GAAoB,CAAC,KAAK,WAAN,CAApB;AAwBT,UAAM,OAAO,GAAG,oBAAoB,CAAC,kBAAkB,CAAC,WAAnB,EAAD,EAAmC,SAAnC,EAA8C,CAAC,WAAD,EAAc,MAAd,CAA9C,CAApC;AAEA,IAAA,OAAO,CAAC,KAAK,WAAN,EAAmB,KAAK,SAAxB,CAAP;AAEA,SAAK,IAAL,GAAY,OAAO,CAAC,IAApB;AAEA,SAAK,SAAL,GAAiB,IAAI,KAAJ,CAAU;AAC1B,MAAA,OAAO,EAAE,KAAK,OADY;AAE1B,MAAA,KAAK,EAAE,KAAK,WAAL,CAAiB,SAFE;AAG1B,MAAA,KAAK,EAAE,WAHmB;AAI1B,MAAA,KAAK,EAAE,OAAO,CAAC;AAJW,KAAV,CAAjB;AAOA,SAAK,MAAL,GAAc,IAAI,KAAJ,CAAU;AACvB,MAAA,OAAO,EAAE,KAAK,OADS;AAEvB,MAAA,KAAK,EAAE,KAAK,WAAL,CAAiB,MAFD;AAGvB,MAAA,KAAK,EAAE,OAHgB;AAIvB,MAAA,KAAK,EAAE,OAAO,CAAC;AAJQ,KAAV,CAAd;AAOA,IAAA,QAAQ,CAAC,IAAD,EAAO,CAAC,WAAD,EAAc,QAAd,CAAP,CAAR;AACA;;AAED,SAAO,WAAP,GAAkB;AACjB,WAAO,MAAM,CAAC,MAAP,CAAc,aAAa,CAAC,WAAd,EAAd,EAA2C;AACjD,MAAA,MAAM,EAAE,CADyC;AAEjD,MAAA,SAAS,EAAE,GAFsC;AAGjD,MAAA,IAAI,EAAE;AAH2C,KAA3C,CAAP;AAKA;AAED;;;AAGG;;;AACH,EAAA,KAAK,CAAC,IAAD,EAAY;AAChB,UAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;AACA,SAAK,GAAL,CAAS,OAAT,EAAkB,YAAlB;;AACA,SAAK,UAAL,CAAgB,YAAhB;;AACA,SAAK,WAAL,CAAiB,KAAjB,CAAuB,YAAvB;;AACA,WAAO,IAAP;AACA;;AAES,EAAA,WAAW,CAAC,IAAD,EAAe;AACnC,SAAK,WAAL,CAAiB,IAAjB,CAAsB,IAAtB;AACA;AAED;;;AAGG;;;AACH,EAAA,eAAe,CAAC,YAAD,EAA2B;AACzC,SAAK,WAAL,CAAiB,eAAjB,CAAiC,YAAjC;;AACA,WAAO,IAAP;AACA;AAED;;AAEG;;;AACH,MAAI,IAAJ,GAAQ;AACP,WAAO,KAAK,WAAL,CAAiB,IAAxB;AACA;;AACD,MAAI,IAAJ,CAAS,IAAT,EAA6B;AAC5B,SAAK,WAAL,CAAiB,IAAjB,GAAwB,IAAxB;AACA;AAED;;AAEG;;;AACH,EAAA,OAAO,GAAA;AACN,UAAM,OAAN;;AACA,QAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC7B,WAAK,IAAL;AACA;;AACD,SAAK,WAAL,CAAiB,UAAjB;;AACA,SAAK,SAAL,CAAe,OAAf;AACA,SAAK,MAAL,CAAY,OAAZ;AACA,WAAO,IAAP;AACA;;AA9G8E","sourceRoot":"","sourcesContent":["import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\nexport class ToneOscillatorNode extends OneShotSource {\n    constructor() {\n        super(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n        this.name = \"ToneOscillatorNode\";\n        /**\n         * The oscillator\n         */\n        this._oscillator = this.context.createOscillator();\n        this._internalChannels = [this._oscillator];\n        const options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        connect(this._oscillator, this._gainNode);\n        this.type = options.type;\n        this.frequency = new Param({\n            context: this.context,\n            param: this._oscillator.frequency,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this.detune = new Param({\n            context: this.context,\n            param: this._oscillator.detune,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, [\"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(OneShotSource.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            type: \"sine\",\n        });\n    }\n    /**\n     * Start the oscillator node at the given time\n     * @param  time When to start the oscillator\n     */\n    start(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"start\", computedTime);\n        this._startGain(computedTime);\n        this._oscillator.start(computedTime);\n        return this;\n    }\n    _stopSource(time) {\n        this._oscillator.stop(time);\n    }\n    /**\n     * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n     * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n     */\n    setPeriodicWave(periodicWave) {\n        this._oscillator.setPeriodicWave(periodicWave);\n        return this;\n    }\n    /**\n     * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n     */\n    get type() {\n        return this._oscillator.type;\n    }\n    set type(type) {\n        this._oscillator.type = type;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        if (this.state === \"started\") {\n            this.stop();\n        }\n        this._oscillator.disconnect();\n        this.frequency.dispose();\n        this.detune.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=ToneOscillatorNode.js.map"]},"metadata":{},"sourceType":"module"}