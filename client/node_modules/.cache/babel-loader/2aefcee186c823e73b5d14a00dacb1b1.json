{"ast":null,"code":"import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\n\nexport class Analyser extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n    this.name = \"Analyser\";\n    /**\n     * The analyser node.\n     */\n\n    this._analysers = [];\n    /**\n     * The buffer that the FFT data is written to\n     */\n\n    this._buffers = [];\n    const options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n    this.input = this.output = this._gain = new Gain({\n      context: this.context\n    });\n    this._split = new Split({\n      context: this.context,\n      channels: options.channels\n    });\n    this.input.connect(this._split);\n    assertRange(options.channels, 1); // create the analysers\n\n    for (let channel = 0; channel < options.channels; channel++) {\n      this._analysers[channel] = this.context.createAnalyser();\n\n      this._split.connect(this._analysers[channel], channel, 0);\n    } // set the values initially\n\n\n    this.size = options.size;\n    this.type = options.type;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      size: 1024,\n      smoothing: 0.8,\n      type: \"fft\",\n      channels: 1\n    });\n  }\n  /**\n   * Run the analysis given the current settings. If [[channels]] = 1,\n   * it will return a Float32Array. If [[channels]] > 1, it will\n   * return an array of Float32Arrays where each index in the array\n   * represents the analysis done on a channel.\n   */\n\n\n  getValue() {\n    this._analysers.forEach((analyser, index) => {\n      const buffer = this._buffers[index];\n\n      if (this._type === \"fft\") {\n        analyser.getFloatFrequencyData(buffer);\n      } else if (this._type === \"waveform\") {\n        analyser.getFloatTimeDomainData(buffer);\n      }\n    });\n\n    if (this.channels === 1) {\n      return this._buffers[0];\n    } else {\n      return this._buffers;\n    }\n  }\n  /**\n   * The size of analysis. This must be a power of two in the range 16 to 16384.\n   */\n\n\n  get size() {\n    return this._analysers[0].frequencyBinCount;\n  }\n\n  set size(size) {\n    this._analysers.forEach((analyser, index) => {\n      analyser.fftSize = size * 2;\n      this._buffers[index] = new Float32Array(size);\n    });\n  }\n  /**\n   * The number of channels the analyser does the analysis on. Channel\n   * separation is done using [[Split]]\n   */\n\n\n  get channels() {\n    return this._analysers.length;\n  }\n  /**\n   * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    assert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n    this._type = type;\n  }\n  /**\n   * 0 represents no time averaging with the last analysis frame.\n   */\n\n\n  get smoothing() {\n    return this._analysers[0].smoothingTimeConstant;\n  }\n\n  set smoothing(val) {\n    this._analysers.forEach(a => a.smoothingTimeConstant = val);\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._analysers.forEach(a => a.disconnect());\n\n    this._split.dispose();\n\n    this._gain.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/component/analysis/Analyser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n        this.name = \"Analyser\";\n        /**\n         * The analyser node.\n         */\n        this._analysers = [];\n        /**\n         * The buffer that the FFT data is written to\n         */\n        this._buffers = [];\n        const options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n        this.input = this.output = this._gain = new Gain({ context: this.context });\n        this._split = new Split({\n            context: this.context,\n            channels: options.channels,\n        });\n        this.input.connect(this._split);\n        assertRange(options.channels, 1);\n        // create the analysers\n        for (let channel = 0; channel < options.channels; channel++) {\n            this._analysers[channel] = this.context.createAnalyser();\n            this._split.connect(this._analysers[channel], channel, 0);\n        }\n        // set the values initially\n        this.size = options.size;\n        this.type = options.type;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            size: 1024,\n            smoothing: 0.8,\n            type: \"fft\",\n            channels: 1,\n        });\n    }\n    /**\n     * Run the analysis given the current settings. If [[channels]] = 1,\n     * it will return a Float32Array. If [[channels]] > 1, it will\n     * return an array of Float32Arrays where each index in the array\n     * represents the analysis done on a channel.\n     */\n    getValue() {\n        this._analysers.forEach((analyser, index) => {\n            const buffer = this._buffers[index];\n            if (this._type === \"fft\") {\n                analyser.getFloatFrequencyData(buffer);\n            }\n            else if (this._type === \"waveform\") {\n                analyser.getFloatTimeDomainData(buffer);\n            }\n        });\n        if (this.channels === 1) {\n            return this._buffers[0];\n        }\n        else {\n            return this._buffers;\n        }\n    }\n    /**\n     * The size of analysis. This must be a power of two in the range 16 to 16384.\n     */\n    get size() {\n        return this._analysers[0].frequencyBinCount;\n    }\n    set size(size) {\n        this._analysers.forEach((analyser, index) => {\n            analyser.fftSize = size * 2;\n            this._buffers[index] = new Float32Array(size);\n        });\n    }\n    /**\n     * The number of channels the analyser does the analysis on. Channel\n     * separation is done using [[Split]]\n     */\n    get channels() {\n        return this._analysers.length;\n    }\n    /**\n     * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n     */\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        assert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n        this._type = type;\n    }\n    /**\n     * 0 represents no time averaging with the last analysis frame.\n     */\n    get smoothing() {\n        return this._analysers[0].smoothingTimeConstant;\n    }\n    set smoothing(val) {\n        this._analysers.forEach(a => a.smoothingTimeConstant = val);\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._analysers.forEach(a => a.disconnect());\n        this._split.dispose();\n        this._gain.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Analyser.js.map"]},"metadata":{},"sourceType":"module"}