{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\nconst OmniOscillatorSourceMap = {\n  am: AMOscillator,\n  fat: FatOscillator,\n  fm: FMOscillator,\n  oscillator: Oscillator,\n  pulse: PulseOscillator,\n  pwm: PWMOscillator\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\n\nexport class OmniOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"OmniOscillator\";\n    const options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, [\"frequency\", \"detune\"]); // set the options\n\n    this.set(options);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    this._oscillator.start(time);\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _stop(time) {\n    this._oscillator.stop(time);\n  }\n\n  _restart(time) {\n    this._oscillator.restart(time);\n\n    return this;\n  }\n  /**\n   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n   * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n   * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n   * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n   * when it's not.\n   * @example\n   * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n   * omniOsc.type = \"pwm\";\n   * // modulationFrequency is parameter which is available\n   * // only when the type is \"pwm\".\n   * omniOsc.modulationFrequency.value = 0.5;\n   */\n\n\n  get type() {\n    let prefix = \"\";\n\n    if ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n      prefix = this._sourceType;\n    }\n\n    return prefix + this._oscillator.type;\n  }\n\n  set type(type) {\n    if (type.substr(0, 2) === \"fm\") {\n      this._createNewOscillator(\"fm\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(2);\n    } else if (type.substr(0, 2) === \"am\") {\n      this._createNewOscillator(\"am\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(2);\n    } else if (type.substr(0, 3) === \"fat\") {\n      this._createNewOscillator(\"fat\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(3);\n    } else if (type === \"pwm\") {\n      this._createNewOscillator(\"pwm\");\n\n      this._oscillator = this._oscillator;\n    } else if (type === \"pulse\") {\n      this._createNewOscillator(\"pulse\");\n    } else {\n      this._createNewOscillator(\"oscillator\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type;\n    }\n  }\n  /**\n   * The value is an empty array when the type is not \"custom\".\n   * This is not available on \"pwm\" and \"pulse\" oscillator types.\n   * See [[Oscillator.partials]]\n   */\n\n\n  get partials() {\n    return this._oscillator.partials;\n  }\n\n  set partials(partials) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n      this._oscillator.partials = partials;\n    }\n  }\n\n  get partialCount() {\n    return this._oscillator.partialCount;\n  }\n\n  set partialCount(partialCount) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n      this._oscillator.partialCount = partialCount;\n    }\n  }\n\n  set(props) {\n    // make sure the type is set first\n    if (Reflect.has(props, \"type\") && props.type) {\n      this.type = props.type;\n    } // then set the rest\n\n\n    super.set(props);\n    return this;\n  }\n  /**\n   * connect the oscillator to the frequency and detune signals\n   */\n\n\n  _createNewOscillator(oscType) {\n    if (oscType !== this._sourceType) {\n      this._sourceType = oscType;\n      const OscConstructor = OmniOscillatorSourceMap[oscType]; // short delay to avoid clicks on the change\n\n      const now = this.now();\n\n      if (this._oscillator) {\n        const oldOsc = this._oscillator;\n        oldOsc.stop(now); // dispose the old one\n\n        this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n      }\n\n      this._oscillator = new OscConstructor({\n        context: this.context\n      });\n      this.frequency.connect(this._oscillator.frequency);\n      this.detune.connect(this._oscillator.detune);\n\n      this._oscillator.connect(this.output);\n\n      this._oscillator.onstop = () => this.onstop(this);\n\n      if (this.state === \"started\") {\n        this._oscillator.start(now);\n      }\n    }\n  }\n\n  get phase() {\n    return this._oscillator.phase;\n  }\n\n  set phase(phase) {\n    this._oscillator.phase = phase;\n  }\n  /**\n   * The source type of the oscillator.\n   * @example\n   * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n   * console.log(omniOsc.sourceType); // 'fm'\n   */\n\n\n  get sourceType() {\n    return this._sourceType;\n  }\n\n  set sourceType(sType) {\n    // the basetype defaults to sine\n    let baseType = \"sine\";\n\n    if (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n      baseType = this._oscillator.type;\n    } // set the type\n\n\n    if (sType === \"fm\") {\n      this.type = \"fm\" + baseType;\n    } else if (sType === \"am\") {\n      this.type = \"am\" + baseType;\n    } else if (sType === \"fat\") {\n      this.type = \"fat\" + baseType;\n    } else if (sType === \"oscillator\") {\n      this.type = baseType;\n    } else if (sType === \"pulse\") {\n      this.type = \"pulse\";\n    } else if (sType === \"pwm\") {\n      this.type = \"pwm\";\n    }\n  }\n\n  _getOscType(osc, sourceType) {\n    return osc instanceof OmniOscillatorSourceMap[sourceType];\n  }\n  /**\n   * The base type of the oscillator. See [[Oscillator.baseType]]\n   * @example\n   * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n   */\n\n\n  get baseType() {\n    return this._oscillator.baseType;\n  }\n\n  set baseType(baseType) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\") && baseType !== \"pulse\" && baseType !== \"pwm\") {\n      this._oscillator.baseType = baseType;\n    }\n  }\n  /**\n   * The width of the oscillator when sourceType === \"pulse\".\n   * See [[PWMOscillator.width]]\n   */\n\n\n  get width() {\n    if (this._getOscType(this._oscillator, \"pulse\")) {\n      return this._oscillator.width;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The number of detuned oscillators when sourceType === \"fat\".\n   * See [[FatOscillator.count]]\n   */\n\n\n  get count() {\n    if (this._getOscType(this._oscillator, \"fat\")) {\n      return this._oscillator.count;\n    } else {\n      return undefined;\n    }\n  }\n\n  set count(count) {\n    if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n      this._oscillator.count = count;\n    }\n  }\n  /**\n   * The detune spread between the oscillators when sourceType === \"fat\".\n   * See [[FatOscillator.count]]\n   */\n\n\n  get spread() {\n    if (this._getOscType(this._oscillator, \"fat\")) {\n      return this._oscillator.spread;\n    } else {\n      return undefined;\n    }\n  }\n\n  set spread(spread) {\n    if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n      this._oscillator.spread = spread;\n    }\n  }\n  /**\n   * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n   * See [[AMOscillator]] or [[FMOscillator]]\n   */\n\n\n  get modulationType() {\n    if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n      return this._oscillator.modulationType;\n    } else {\n      return undefined;\n    }\n  }\n\n  set modulationType(mType) {\n    if ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n      this._oscillator.modulationType = mType;\n    }\n  }\n  /**\n   * The modulation index when the sourceType === \"fm\"\n   * See [[FMOscillator]].\n   */\n\n\n  get modulationIndex() {\n    if (this._getOscType(this._oscillator, \"fm\")) {\n      return this._oscillator.modulationIndex;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n   * See [[AMOscillator]] or [[FMOscillator]]\n   */\n\n\n  get harmonicity() {\n    if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n      return this._oscillator.harmonicity;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n   * see [[PWMOscillator]]\n   * @min 0.1\n   * @max 5\n   */\n\n\n  get modulationFrequency() {\n    if (this._getOscType(this._oscillator, \"pwm\")) {\n      return this._oscillator.modulationFrequency;\n    } else {\n      return undefined;\n    }\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.detune.dispose();\n    this.frequency.dispose();\n\n    this._oscillator.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/source/oscillator/OmniOscillator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\nconst OmniOscillatorSourceMap = {\n    am: AMOscillator,\n    fat: FatOscillator,\n    fm: FMOscillator,\n    oscillator: Oscillator,\n    pulse: PulseOscillator,\n    pwm: PWMOscillator,\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class OmniOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n        this.name = \"OmniOscillator\";\n        const options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this.detune = new Signal({\n            context: this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, [\"frequency\", \"detune\"]);\n        // set the options\n        this.set(options);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        this._oscillator.start(time);\n    }\n    /**\n     * start the oscillator\n     */\n    _stop(time) {\n        this._oscillator.stop(time);\n    }\n    _restart(time) {\n        this._oscillator.restart(time);\n        return this;\n    }\n    /**\n     * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n     * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n     * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n     * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n     * when it's not.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n     * omniOsc.type = \"pwm\";\n     * // modulationFrequency is parameter which is available\n     * // only when the type is \"pwm\".\n     * omniOsc.modulationFrequency.value = 0.5;\n     */\n    get type() {\n        let prefix = \"\";\n        if ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n            prefix = this._sourceType;\n        }\n        return prefix + this._oscillator.type;\n    }\n    set type(type) {\n        if (type.substr(0, 2) === \"fm\") {\n            this._createNewOscillator(\"fm\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(2);\n        }\n        else if (type.substr(0, 2) === \"am\") {\n            this._createNewOscillator(\"am\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(2);\n        }\n        else if (type.substr(0, 3) === \"fat\") {\n            this._createNewOscillator(\"fat\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(3);\n        }\n        else if (type === \"pwm\") {\n            this._createNewOscillator(\"pwm\");\n            this._oscillator = this._oscillator;\n        }\n        else if (type === \"pulse\") {\n            this._createNewOscillator(\"pulse\");\n        }\n        else {\n            this._createNewOscillator(\"oscillator\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type;\n        }\n    }\n    /**\n     * The value is an empty array when the type is not \"custom\".\n     * This is not available on \"pwm\" and \"pulse\" oscillator types.\n     * See [[Oscillator.partials]]\n     */\n    get partials() {\n        return this._oscillator.partials;\n    }\n    set partials(partials) {\n        if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n            this._oscillator.partials = partials;\n        }\n    }\n    get partialCount() {\n        return this._oscillator.partialCount;\n    }\n    set partialCount(partialCount) {\n        if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n            this._oscillator.partialCount = partialCount;\n        }\n    }\n    set(props) {\n        // make sure the type is set first\n        if (Reflect.has(props, \"type\") && props.type) {\n            this.type = props.type;\n        }\n        // then set the rest\n        super.set(props);\n        return this;\n    }\n    /**\n     * connect the oscillator to the frequency and detune signals\n     */\n    _createNewOscillator(oscType) {\n        if (oscType !== this._sourceType) {\n            this._sourceType = oscType;\n            const OscConstructor = OmniOscillatorSourceMap[oscType];\n            // short delay to avoid clicks on the change\n            const now = this.now();\n            if (this._oscillator) {\n                const oldOsc = this._oscillator;\n                oldOsc.stop(now);\n                // dispose the old one\n                this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n            }\n            this._oscillator = new OscConstructor({\n                context: this.context,\n            });\n            this.frequency.connect(this._oscillator.frequency);\n            this.detune.connect(this._oscillator.detune);\n            this._oscillator.connect(this.output);\n            this._oscillator.onstop = () => this.onstop(this);\n            if (this.state === \"started\") {\n                this._oscillator.start(now);\n            }\n        }\n    }\n    get phase() {\n        return this._oscillator.phase;\n    }\n    set phase(phase) {\n        this._oscillator.phase = phase;\n    }\n    /**\n     * The source type of the oscillator.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n     * console.log(omniOsc.sourceType); // 'fm'\n     */\n    get sourceType() {\n        return this._sourceType;\n    }\n    set sourceType(sType) {\n        // the basetype defaults to sine\n        let baseType = \"sine\";\n        if (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n            baseType = this._oscillator.type;\n        }\n        // set the type\n        if (sType === \"fm\") {\n            this.type = \"fm\" + baseType;\n        }\n        else if (sType === \"am\") {\n            this.type = \"am\" + baseType;\n        }\n        else if (sType === \"fat\") {\n            this.type = \"fat\" + baseType;\n        }\n        else if (sType === \"oscillator\") {\n            this.type = baseType;\n        }\n        else if (sType === \"pulse\") {\n            this.type = \"pulse\";\n        }\n        else if (sType === \"pwm\") {\n            this.type = \"pwm\";\n        }\n    }\n    _getOscType(osc, sourceType) {\n        return osc instanceof OmniOscillatorSourceMap[sourceType];\n    }\n    /**\n     * The base type of the oscillator. See [[Oscillator.baseType]]\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n     * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n     */\n    get baseType() {\n        return this._oscillator.baseType;\n    }\n    set baseType(baseType) {\n        if (!this._getOscType(this._oscillator, \"pulse\") &&\n            !this._getOscType(this._oscillator, \"pwm\") &&\n            baseType !== \"pulse\" && baseType !== \"pwm\") {\n            this._oscillator.baseType = baseType;\n        }\n    }\n    /**\n     * The width of the oscillator when sourceType === \"pulse\".\n     * See [[PWMOscillator.width]]\n     */\n    get width() {\n        if (this._getOscType(this._oscillator, \"pulse\")) {\n            return this._oscillator.width;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * The number of detuned oscillators when sourceType === \"fat\".\n     * See [[FatOscillator.count]]\n     */\n    get count() {\n        if (this._getOscType(this._oscillator, \"fat\")) {\n            return this._oscillator.count;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set count(count) {\n        if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n            this._oscillator.count = count;\n        }\n    }\n    /**\n     * The detune spread between the oscillators when sourceType === \"fat\".\n     * See [[FatOscillator.count]]\n     */\n    get spread() {\n        if (this._getOscType(this._oscillator, \"fat\")) {\n            return this._oscillator.spread;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set spread(spread) {\n        if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n            this._oscillator.spread = spread;\n        }\n    }\n    /**\n     * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n     * See [[AMOscillator]] or [[FMOscillator]]\n     */\n    get modulationType() {\n        if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n            return this._oscillator.modulationType;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set modulationType(mType) {\n        if ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n            this._oscillator.modulationType = mType;\n        }\n    }\n    /**\n     * The modulation index when the sourceType === \"fm\"\n     * See [[FMOscillator]].\n     */\n    get modulationIndex() {\n        if (this._getOscType(this._oscillator, \"fm\")) {\n            return this._oscillator.modulationIndex;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n     * See [[AMOscillator]] or [[FMOscillator]]\n     */\n    get harmonicity() {\n        if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n            return this._oscillator.harmonicity;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n     * see [[PWMOscillator]]\n     * @min 0.1\n     * @max 5\n     */\n    get modulationFrequency() {\n        if (this._getOscType(this._oscillator, \"pwm\")) {\n            return this._oscillator.modulationFrequency;\n        }\n        else {\n            return undefined;\n        }\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    dispose() {\n        super.dispose();\n        this.detune.dispose();\n        this.frequency.dispose();\n        this._oscillator.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=OmniOscillator.js.map"]},"metadata":{},"sourceType":"module"}