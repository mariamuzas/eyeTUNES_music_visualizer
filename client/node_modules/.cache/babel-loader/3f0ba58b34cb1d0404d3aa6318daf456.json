{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\n\nexport class Oscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"Oscillator\";\n    /**\n     * the main oscillator\n     */\n\n    this._oscillator = null;\n    const options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\");\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, \"detune\");\n    this._partials = options.partials;\n    this._partialCount = options.partialCount;\n    this._type = options.type;\n\n    if (options.partialCount && options.type !== \"custom\") {\n      this._type = this.baseType + options.partialCount.toString();\n    }\n\n    this.phase = options.phase;\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      partialCount: 0,\n      partials: [],\n      phase: 0,\n      type: \"sine\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    const computedTime = this.toSeconds(time); // new oscillator with previous values\n\n    const oscillator = new ToneOscillatorNode({\n      context: this.context,\n      onended: () => this.onstop(this)\n    });\n    this._oscillator = oscillator;\n\n    if (this._wave) {\n      this._oscillator.setPeriodicWave(this._wave);\n    } else {\n      this._oscillator.type = this._type;\n    } // connect the control signal to the oscillator frequency & detune\n\n\n    this._oscillator.connect(this.output);\n\n    this.frequency.connect(this._oscillator.frequency);\n    this.detune.connect(this._oscillator.detune); // start the oscillator\n\n    this._oscillator.start(computedTime);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._oscillator) {\n      this._oscillator.stop(computedTime);\n    }\n  }\n  /**\n   * Restart the oscillator. Does not stop the oscillator, but instead\n   * just cancels any scheduled 'stop' from being invoked.\n   */\n\n\n  _restart(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"restart\", computedTime);\n\n    if (this._oscillator) {\n      this._oscillator.cancelStop();\n    }\n\n    this._state.cancel(computedTime);\n\n    return this;\n  }\n  /**\n   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n   * will also affect the oscillators frequency.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * osc.frequency.value = 440;\n   * // the ratio between the bpm and the frequency will be maintained\n   * osc.syncFrequency();\n   * // double the tempo\n   * Tone.Transport.bpm.value *= 2;\n   * // the frequency of the oscillator is doubled to 880\n   */\n\n\n  syncFrequency() {\n    this.context.transport.syncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Unsync the oscillator's frequency from the Transport.\n   * See Oscillator.syncFrequency\n   */\n\n\n  unsyncFrequency() {\n    this.context.transport.unsyncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Get a cached periodic wave. Avoids having to recompute\n   * the oscillator values when they have already been computed\n   * with the same values.\n   */\n\n\n  _getCachedPeriodicWave() {\n    if (this._type === \"custom\") {\n      const oscProps = Oscillator._periodicWaveCache.find(description => {\n        return description.phase === this._phase && deepEquals(description.partials, this._partials);\n      });\n\n      return oscProps;\n    } else {\n      const oscProps = Oscillator._periodicWaveCache.find(description => {\n        return description.type === this._type && description.phase === this._phase;\n      });\n\n      this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n      return oscProps;\n    }\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n    const isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\n    if (this._phase === 0 && isBasicType) {\n      this._wave = undefined;\n      this._partialCount = 0; // just go with the basic approach\n\n      if (this._oscillator !== null) {\n        // already tested that it's a basic type\n        this._oscillator.type = type;\n      }\n    } else {\n      // first check if the value is cached\n      const cache = this._getCachedPeriodicWave();\n\n      if (isDefined(cache)) {\n        const {\n          partials,\n          wave\n        } = cache;\n        this._wave = wave;\n        this._partials = partials;\n\n        if (this._oscillator !== null) {\n          this._oscillator.setPeriodicWave(this._wave);\n        }\n      } else {\n        const [real, imag] = this._getRealImaginary(type, this._phase);\n\n        const periodicWave = this.context.createPeriodicWave(real, imag);\n        this._wave = periodicWave;\n\n        if (this._oscillator !== null) {\n          this._oscillator.setPeriodicWave(this._wave);\n        } // set the cache\n\n\n        Oscillator._periodicWaveCache.push({\n          imag,\n          partialCount: this._partialCount,\n          partials: this._partials,\n          phase: this._phase,\n          real,\n          type: this._type,\n          wave: this._wave\n        });\n\n        if (Oscillator._periodicWaveCache.length > 100) {\n          Oscillator._periodicWaveCache.shift();\n        }\n      }\n    }\n  }\n\n  get baseType() {\n    return this._type.replace(this.partialCount.toString(), \"\");\n  }\n\n  set baseType(baseType) {\n    if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n      this.type = baseType + this.partialCount;\n    } else {\n      this.type = baseType;\n    }\n  }\n\n  get partialCount() {\n    return this._partialCount;\n  }\n\n  set partialCount(p) {\n    assertRange(p, 0);\n    let type = this._type;\n    const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\n    if (partial) {\n      type = partial[1];\n    }\n\n    if (this._type !== \"custom\") {\n      if (p === 0) {\n        this.type = type;\n      } else {\n        this.type = type + p.toString();\n      }\n    } else {\n      // extend or shorten the partials array\n      const fullPartials = new Float32Array(p); // copy over the partials array\n\n      this._partials.forEach((v, i) => fullPartials[i] = v);\n\n      this._partials = Array.from(fullPartials);\n      this.type = this._type;\n    }\n  }\n  /**\n   * Returns the real and imaginary components based\n   * on the oscillator type.\n   * @returns [real: Float32Array, imaginary: Float32Array]\n   */\n\n\n  _getRealImaginary(type, phase) {\n    const fftSize = 4096;\n    let periodicWaveSize = fftSize / 2;\n    const real = new Float32Array(periodicWaveSize);\n    const imag = new Float32Array(periodicWaveSize);\n    let partialCount = 1;\n\n    if (type === \"custom\") {\n      partialCount = this._partials.length + 1;\n      this._partialCount = this._partials.length;\n      periodicWaveSize = partialCount; // if the partial count is 0, don't bother doing any computation\n\n      if (this._partials.length === 0) {\n        return [real, imag];\n      }\n    } else {\n      const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\n      if (partial) {\n        partialCount = parseInt(partial[2], 10) + 1;\n        this._partialCount = parseInt(partial[2], 10);\n        type = partial[1];\n        partialCount = Math.max(partialCount, 2);\n        periodicWaveSize = partialCount;\n      } else {\n        this._partialCount = 0;\n      }\n\n      this._partials = [];\n    }\n\n    for (let n = 1; n < periodicWaveSize; ++n) {\n      const piFactor = 2 / (n * Math.PI);\n      let b;\n\n      switch (type) {\n        case \"sine\":\n          b = n <= partialCount ? 1 : 0;\n          this._partials[n - 1] = b;\n          break;\n\n        case \"square\":\n          b = n & 1 ? 2 * piFactor : 0;\n          this._partials[n - 1] = b;\n          break;\n\n        case \"sawtooth\":\n          b = piFactor * (n & 1 ? 1 : -1);\n          this._partials[n - 1] = b;\n          break;\n\n        case \"triangle\":\n          if (n & 1) {\n            b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);\n          } else {\n            b = 0;\n          }\n\n          this._partials[n - 1] = b;\n          break;\n\n        case \"custom\":\n          b = this._partials[n - 1];\n          break;\n\n        default:\n          throw new TypeError(\"Oscillator: invalid type: \" + type);\n      }\n\n      if (b !== 0) {\n        real[n] = -b * Math.sin(phase * n);\n        imag[n] = b * Math.cos(phase * n);\n      } else {\n        real[n] = 0;\n        imag[n] = 0;\n      }\n    }\n\n    return [real, imag];\n  }\n  /**\n   * Compute the inverse FFT for a given phase.\n   */\n\n\n  _inverseFFT(real, imag, phase) {\n    let sum = 0;\n    const len = real.length;\n\n    for (let i = 0; i < len; i++) {\n      sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n    }\n\n    return sum;\n  }\n  /**\n   * Returns the initial value of the oscillator when stopped.\n   * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n   */\n\n\n  getInitialValue() {\n    const [real, imag] = this._getRealImaginary(this._type, 0);\n\n    let maxValue = 0;\n    const twoPi = Math.PI * 2;\n    const testPositions = 32; // check for peaks in 16 places\n\n    for (let i = 0; i < testPositions; i++) {\n      maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);\n    }\n\n    return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n  }\n\n  get partials() {\n    return this._partials.slice(0, this.partialCount);\n  }\n\n  set partials(partials) {\n    this._partials = partials;\n    this._partialCount = this._partials.length;\n\n    if (partials.length) {\n      this.type = \"custom\";\n    }\n  }\n\n  get phase() {\n    return this._phase * (180 / Math.PI);\n  }\n\n  set phase(phase) {\n    this._phase = phase * Math.PI / 180; // reset the type\n\n    this.type = this._type;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._oscillator !== null) {\n      this._oscillator.dispose();\n    }\n\n    this._wave = undefined;\n    this.frequency.dispose();\n    this.detune.dispose();\n    return this;\n  }\n\n}\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\n\nOscillator._periodicWaveCache = [];","map":{"version":3,"sources":["../../../../Tone/source/oscillator/Oscillator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n        this.name = \"Oscillator\";\n        /**\n         * the main oscillator\n         */\n        this._oscillator = null;\n        const options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        readOnly(this, \"frequency\");\n        this.detune = new Signal({\n            context: this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, \"detune\");\n        this._partials = options.partials;\n        this._partialCount = options.partialCount;\n        this._type = options.type;\n        if (options.partialCount && options.type !== \"custom\") {\n            this._type = this.baseType + options.partialCount.toString();\n        }\n        this.phase = options.phase;\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            partialCount: 0,\n            partials: [],\n            phase: 0,\n            type: \"sine\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        const computedTime = this.toSeconds(time);\n        // new oscillator with previous values\n        const oscillator = new ToneOscillatorNode({\n            context: this.context,\n            onended: () => this.onstop(this),\n        });\n        this._oscillator = oscillator;\n        if (this._wave) {\n            this._oscillator.setPeriodicWave(this._wave);\n        }\n        else {\n            this._oscillator.type = this._type;\n        }\n        // connect the control signal to the oscillator frequency & detune\n        this._oscillator.connect(this.output);\n        this.frequency.connect(this._oscillator.frequency);\n        this.detune.connect(this._oscillator.detune);\n        // start the oscillator\n        this._oscillator.start(computedTime);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._oscillator) {\n            this._oscillator.stop(computedTime);\n        }\n    }\n    /**\n     * Restart the oscillator. Does not stop the oscillator, but instead\n     * just cancels any scheduled 'stop' from being invoked.\n     */\n    _restart(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"restart\", computedTime);\n        if (this._oscillator) {\n            this._oscillator.cancelStop();\n        }\n        this._state.cancel(computedTime);\n        return this;\n    }\n    /**\n     * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n     * will also affect the oscillators frequency.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * osc.frequency.value = 440;\n     * // the ratio between the bpm and the frequency will be maintained\n     * osc.syncFrequency();\n     * // double the tempo\n     * Tone.Transport.bpm.value *= 2;\n     * // the frequency of the oscillator is doubled to 880\n     */\n    syncFrequency() {\n        this.context.transport.syncSignal(this.frequency);\n        return this;\n    }\n    /**\n     * Unsync the oscillator's frequency from the Transport.\n     * See Oscillator.syncFrequency\n     */\n    unsyncFrequency() {\n        this.context.transport.unsyncSignal(this.frequency);\n        return this;\n    }\n    /**\n     * Get a cached periodic wave. Avoids having to recompute\n     * the oscillator values when they have already been computed\n     * with the same values.\n     */\n    _getCachedPeriodicWave() {\n        if (this._type === \"custom\") {\n            const oscProps = Oscillator._periodicWaveCache.find(description => {\n                return description.phase === this._phase &&\n                    deepEquals(description.partials, this._partials);\n            });\n            return oscProps;\n        }\n        else {\n            const oscProps = Oscillator._periodicWaveCache.find(description => {\n                return description.type === this._type &&\n                    description.phase === this._phase;\n            });\n            this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n            return oscProps;\n        }\n    }\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        this._type = type;\n        const isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n        if (this._phase === 0 && isBasicType) {\n            this._wave = undefined;\n            this._partialCount = 0;\n            // just go with the basic approach\n            if (this._oscillator !== null) {\n                // already tested that it's a basic type\n                this._oscillator.type = type;\n            }\n        }\n        else {\n            // first check if the value is cached\n            const cache = this._getCachedPeriodicWave();\n            if (isDefined(cache)) {\n                const { partials, wave } = cache;\n                this._wave = wave;\n                this._partials = partials;\n                if (this._oscillator !== null) {\n                    this._oscillator.setPeriodicWave(this._wave);\n                }\n            }\n            else {\n                const [real, imag] = this._getRealImaginary(type, this._phase);\n                const periodicWave = this.context.createPeriodicWave(real, imag);\n                this._wave = periodicWave;\n                if (this._oscillator !== null) {\n                    this._oscillator.setPeriodicWave(this._wave);\n                }\n                // set the cache\n                Oscillator._periodicWaveCache.push({\n                    imag,\n                    partialCount: this._partialCount,\n                    partials: this._partials,\n                    phase: this._phase,\n                    real,\n                    type: this._type,\n                    wave: this._wave,\n                });\n                if (Oscillator._periodicWaveCache.length > 100) {\n                    Oscillator._periodicWaveCache.shift();\n                }\n            }\n        }\n    }\n    get baseType() {\n        return this._type.replace(this.partialCount.toString(), \"\");\n    }\n    set baseType(baseType) {\n        if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n            this.type = baseType + this.partialCount;\n        }\n        else {\n            this.type = baseType;\n        }\n    }\n    get partialCount() {\n        return this._partialCount;\n    }\n    set partialCount(p) {\n        assertRange(p, 0);\n        let type = this._type;\n        const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n        if (partial) {\n            type = partial[1];\n        }\n        if (this._type !== \"custom\") {\n            if (p === 0) {\n                this.type = type;\n            }\n            else {\n                this.type = type + p.toString();\n            }\n        }\n        else {\n            // extend or shorten the partials array\n            const fullPartials = new Float32Array(p);\n            // copy over the partials array\n            this._partials.forEach((v, i) => fullPartials[i] = v);\n            this._partials = Array.from(fullPartials);\n            this.type = this._type;\n        }\n    }\n    /**\n     * Returns the real and imaginary components based\n     * on the oscillator type.\n     * @returns [real: Float32Array, imaginary: Float32Array]\n     */\n    _getRealImaginary(type, phase) {\n        const fftSize = 4096;\n        let periodicWaveSize = fftSize / 2;\n        const real = new Float32Array(periodicWaveSize);\n        const imag = new Float32Array(periodicWaveSize);\n        let partialCount = 1;\n        if (type === \"custom\") {\n            partialCount = this._partials.length + 1;\n            this._partialCount = this._partials.length;\n            periodicWaveSize = partialCount;\n            // if the partial count is 0, don't bother doing any computation\n            if (this._partials.length === 0) {\n                return [real, imag];\n            }\n        }\n        else {\n            const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n            if (partial) {\n                partialCount = parseInt(partial[2], 10) + 1;\n                this._partialCount = parseInt(partial[2], 10);\n                type = partial[1];\n                partialCount = Math.max(partialCount, 2);\n                periodicWaveSize = partialCount;\n            }\n            else {\n                this._partialCount = 0;\n            }\n            this._partials = [];\n        }\n        for (let n = 1; n < periodicWaveSize; ++n) {\n            const piFactor = 2 / (n * Math.PI);\n            let b;\n            switch (type) {\n                case \"sine\":\n                    b = (n <= partialCount) ? 1 : 0;\n                    this._partials[n - 1] = b;\n                    break;\n                case \"square\":\n                    b = (n & 1) ? 2 * piFactor : 0;\n                    this._partials[n - 1] = b;\n                    break;\n                case \"sawtooth\":\n                    b = piFactor * ((n & 1) ? 1 : -1);\n                    this._partials[n - 1] = b;\n                    break;\n                case \"triangle\":\n                    if (n & 1) {\n                        b = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n                    }\n                    else {\n                        b = 0;\n                    }\n                    this._partials[n - 1] = b;\n                    break;\n                case \"custom\":\n                    b = this._partials[n - 1];\n                    break;\n                default:\n                    throw new TypeError(\"Oscillator: invalid type: \" + type);\n            }\n            if (b !== 0) {\n                real[n] = -b * Math.sin(phase * n);\n                imag[n] = b * Math.cos(phase * n);\n            }\n            else {\n                real[n] = 0;\n                imag[n] = 0;\n            }\n        }\n        return [real, imag];\n    }\n    /**\n     * Compute the inverse FFT for a given phase.\n     */\n    _inverseFFT(real, imag, phase) {\n        let sum = 0;\n        const len = real.length;\n        for (let i = 0; i < len; i++) {\n            sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n        }\n        return sum;\n    }\n    /**\n     * Returns the initial value of the oscillator when stopped.\n     * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n     */\n    getInitialValue() {\n        const [real, imag] = this._getRealImaginary(this._type, 0);\n        let maxValue = 0;\n        const twoPi = Math.PI * 2;\n        const testPositions = 32;\n        // check for peaks in 16 places\n        for (let i = 0; i < testPositions; i++) {\n            maxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n        }\n        return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n    }\n    get partials() {\n        return this._partials.slice(0, this.partialCount);\n    }\n    set partials(partials) {\n        this._partials = partials;\n        this._partialCount = this._partials.length;\n        if (partials.length) {\n            this.type = \"custom\";\n        }\n    }\n    get phase() {\n        return this._phase * (180 / Math.PI);\n    }\n    set phase(phase) {\n        this._phase = phase * Math.PI / 180;\n        // reset the type\n        this.type = this._type;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._oscillator !== null) {\n            this._oscillator.dispose();\n        }\n        this._wave = undefined;\n        this.frequency.dispose();\n        this.detune.dispose();\n        return this;\n    }\n}\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\nOscillator._periodicWaveCache = [];\n//# sourceMappingURL=Oscillator.js.map"]},"metadata":{},"sourceType":"module"}