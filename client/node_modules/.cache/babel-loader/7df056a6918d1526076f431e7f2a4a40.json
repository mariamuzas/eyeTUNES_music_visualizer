{"ast":null,"code":"import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\n\nexport class Emitter extends Tone {\n  constructor() {\n    super(...arguments);\n    this.name = \"Emitter\";\n  }\n  /**\n   * Bind a callback to a specific event.\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n\n\n  on(event, callback) {\n    // split the event\n    const events = event.split(/\\W+/);\n    events.forEach(eventName => {\n      if (isUndef(this._events)) {\n        this._events = {};\n      }\n\n      if (!this._events.hasOwnProperty(eventName)) {\n        this._events[eventName] = [];\n      }\n\n      this._events[eventName].push(callback);\n    });\n    return this;\n  }\n  /**\n   * Bind a callback which is only invoked once\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n\n\n  once(event, callback) {\n    const boundCallback = (...args) => {\n      // invoke the callback\n      callback(...args); // remove the event\n\n      this.off(event, boundCallback);\n    };\n\n    this.on(event, boundCallback);\n    return this;\n  }\n  /**\n   * Remove the event listener.\n   * @param  event     The event to stop listening to.\n   * @param  callback  The callback which was bound to the event with Emitter.on.\n   *                   If no callback is given, all callbacks events are removed.\n   */\n\n\n  off(event, callback) {\n    const events = event.split(/\\W+/);\n    events.forEach(eventName => {\n      if (isUndef(this._events)) {\n        this._events = {};\n      }\n\n      if (this._events.hasOwnProperty(event)) {\n        if (isUndef(callback)) {\n          this._events[event] = [];\n        } else {\n          const eventList = this._events[event];\n\n          for (let i = eventList.length - 1; i >= 0; i--) {\n            if (eventList[i] === callback) {\n              eventList.splice(i, 1);\n            }\n          }\n        }\n      }\n    });\n    return this;\n  }\n  /**\n   * Invoke all of the callbacks bound to the event\n   * with any arguments passed in.\n   * @param  event  The name of the event.\n   * @param args The arguments to pass to the functions listening.\n   */\n\n\n  emit(event, ...args) {\n    if (this._events) {\n      if (this._events.hasOwnProperty(event)) {\n        const eventList = this._events[event].slice(0);\n\n        for (let i = 0, len = eventList.length; i < len; i++) {\n          eventList[i].apply(this, args);\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Add Emitter functions (on/off/emit) to the object\n   */\n\n\n  static mixin(constr) {\n    // instance._events = {};\n    [\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n      const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n      Object.defineProperty(constr.prototype, name, property);\n    });\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._events = undefined;\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/core/util/Emitter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter extends Tone {\n    constructor() {\n        super(...arguments);\n        this.name = \"Emitter\";\n    }\n    /**\n     * Bind a callback to a specific event.\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n    on(event, callback) {\n        // split the event\n        const events = event.split(/\\W+/);\n        events.forEach(eventName => {\n            if (isUndef(this._events)) {\n                this._events = {};\n            }\n            if (!this._events.hasOwnProperty(eventName)) {\n                this._events[eventName] = [];\n            }\n            this._events[eventName].push(callback);\n        });\n        return this;\n    }\n    /**\n     * Bind a callback which is only invoked once\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n    once(event, callback) {\n        const boundCallback = (...args) => {\n            // invoke the callback\n            callback(...args);\n            // remove the event\n            this.off(event, boundCallback);\n        };\n        this.on(event, boundCallback);\n        return this;\n    }\n    /**\n     * Remove the event listener.\n     * @param  event     The event to stop listening to.\n     * @param  callback  The callback which was bound to the event with Emitter.on.\n     *                   If no callback is given, all callbacks events are removed.\n     */\n    off(event, callback) {\n        const events = event.split(/\\W+/);\n        events.forEach(eventName => {\n            if (isUndef(this._events)) {\n                this._events = {};\n            }\n            if (this._events.hasOwnProperty(event)) {\n                if (isUndef(callback)) {\n                    this._events[event] = [];\n                }\n                else {\n                    const eventList = this._events[event];\n                    for (let i = eventList.length - 1; i >= 0; i--) {\n                        if (eventList[i] === callback) {\n                            eventList.splice(i, 1);\n                        }\n                    }\n                }\n            }\n        });\n        return this;\n    }\n    /**\n     * Invoke all of the callbacks bound to the event\n     * with any arguments passed in.\n     * @param  event  The name of the event.\n     * @param args The arguments to pass to the functions listening.\n     */\n    emit(event, ...args) {\n        if (this._events) {\n            if (this._events.hasOwnProperty(event)) {\n                const eventList = this._events[event].slice(0);\n                for (let i = 0, len = eventList.length; i < len; i++) {\n                    eventList[i].apply(this, args);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Add Emitter functions (on/off/emit) to the object\n     */\n    static mixin(constr) {\n        // instance._events = {};\n        [\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n            const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n            Object.defineProperty(constr.prototype, name, property);\n        });\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._events = undefined;\n        return this;\n    }\n}\n//# sourceMappingURL=Emitter.js.map"]},"metadata":{},"sourceType":"module"}