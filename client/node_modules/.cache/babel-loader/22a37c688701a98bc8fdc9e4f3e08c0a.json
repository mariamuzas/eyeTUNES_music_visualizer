{"ast":null,"code":"import { ToneEvent } from \"./ToneEvent\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Loop creates a looped callback at the\n * specified interval. The callback can be\n * started, stopped and scheduled along\n * the Transport's timeline.\n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note.\n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\n\nexport class Loop extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n    this.name = \"Loop\";\n    const options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n    this._event = new ToneEvent({\n      context: this.context,\n      callback: this._tick.bind(this),\n      loop: true,\n      loopEnd: options.interval,\n      playbackRate: options.playbackRate,\n      probability: options.probability\n    });\n    this.callback = options.callback; // set the iterations\n\n    this.iterations = options.iterations;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      interval: \"4n\",\n      callback: noOp,\n      playbackRate: 1,\n      iterations: Infinity,\n      probability: 1,\n      mute: false,\n      humanize: false\n    });\n  }\n  /**\n   * Start the loop at the specified time along the Transport's timeline.\n   * @param  time  When to start the Loop.\n   */\n\n\n  start(time) {\n    this._event.start(time);\n\n    return this;\n  }\n  /**\n   * Stop the loop at the given time.\n   * @param  time  When to stop the Loop.\n   */\n\n\n  stop(time) {\n    this._event.stop(time);\n\n    return this;\n  }\n  /**\n   * Cancel all scheduled events greater than or equal to the given time\n   * @param  time  The time after which events will be cancel.\n   */\n\n\n  cancel(time) {\n    this._event.cancel(time);\n\n    return this;\n  }\n  /**\n   * Internal function called when the notes should be called\n   * @param time  The time the event occurs\n   */\n\n\n  _tick(time) {\n    this.callback(time);\n  }\n  /**\n   * The state of the Loop, either started or stopped.\n   */\n\n\n  get state() {\n    return this._event.state;\n  }\n  /**\n   * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.\n   */\n\n\n  get progress() {\n    return this._event.progress;\n  }\n  /**\n   * The time between successive callbacks.\n   * @example\n   * const loop = new Tone.Loop();\n   * loop.interval = \"8n\"; // loop every 8n\n   */\n\n\n  get interval() {\n    return this._event.loopEnd;\n  }\n\n  set interval(interval) {\n    this._event.loopEnd = interval;\n  }\n  /**\n   * The playback rate of the loop. The normal playback rate is 1 (no change).\n   * A `playbackRate` of 2 would be twice as fast.\n   */\n\n\n  get playbackRate() {\n    return this._event.playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._event.playbackRate = rate;\n  }\n  /**\n   * Random variation +/-0.01s to the scheduled time.\n   * Or give it a time value which it will randomize by.\n   */\n\n\n  get humanize() {\n    return this._event.humanize;\n  }\n\n  set humanize(variation) {\n    this._event.humanize = variation;\n  }\n  /**\n   * The probably of the callback being invoked.\n   */\n\n\n  get probability() {\n    return this._event.probability;\n  }\n\n  set probability(prob) {\n    this._event.probability = prob;\n  }\n  /**\n   * Muting the Loop means that no callbacks are invoked.\n   */\n\n\n  get mute() {\n    return this._event.mute;\n  }\n\n  set mute(mute) {\n    this._event.mute = mute;\n  }\n  /**\n   * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n   */\n\n\n  get iterations() {\n    if (this._event.loop === true) {\n      return Infinity;\n    } else {\n      return this._event.loop;\n    }\n  }\n\n  set iterations(iters) {\n    if (iters === Infinity) {\n      this._event.loop = true;\n    } else {\n      this._event.loop = iters;\n    }\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._event.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/event/Loop.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ToneEvent } from \"./ToneEvent\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Loop creates a looped callback at the\n * specified interval. The callback can be\n * started, stopped and scheduled along\n * the Transport's timeline.\n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note.\n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Loop extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n        this.name = \"Loop\";\n        const options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n        this._event = new ToneEvent({\n            context: this.context,\n            callback: this._tick.bind(this),\n            loop: true,\n            loopEnd: options.interval,\n            playbackRate: options.playbackRate,\n            probability: options.probability\n        });\n        this.callback = options.callback;\n        // set the iterations\n        this.iterations = options.iterations;\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            interval: \"4n\",\n            callback: noOp,\n            playbackRate: 1,\n            iterations: Infinity,\n            probability: 1,\n            mute: false,\n            humanize: false\n        });\n    }\n    /**\n     * Start the loop at the specified time along the Transport's timeline.\n     * @param  time  When to start the Loop.\n     */\n    start(time) {\n        this._event.start(time);\n        return this;\n    }\n    /**\n     * Stop the loop at the given time.\n     * @param  time  When to stop the Loop.\n     */\n    stop(time) {\n        this._event.stop(time);\n        return this;\n    }\n    /**\n     * Cancel all scheduled events greater than or equal to the given time\n     * @param  time  The time after which events will be cancel.\n     */\n    cancel(time) {\n        this._event.cancel(time);\n        return this;\n    }\n    /**\n     * Internal function called when the notes should be called\n     * @param time  The time the event occurs\n     */\n    _tick(time) {\n        this.callback(time);\n    }\n    /**\n     * The state of the Loop, either started or stopped.\n     */\n    get state() {\n        return this._event.state;\n    }\n    /**\n     * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.\n     */\n    get progress() {\n        return this._event.progress;\n    }\n    /**\n     * The time between successive callbacks.\n     * @example\n     * const loop = new Tone.Loop();\n     * loop.interval = \"8n\"; // loop every 8n\n     */\n    get interval() {\n        return this._event.loopEnd;\n    }\n    set interval(interval) {\n        this._event.loopEnd = interval;\n    }\n    /**\n     * The playback rate of the loop. The normal playback rate is 1 (no change).\n     * A `playbackRate` of 2 would be twice as fast.\n     */\n    get playbackRate() {\n        return this._event.playbackRate;\n    }\n    set playbackRate(rate) {\n        this._event.playbackRate = rate;\n    }\n    /**\n     * Random variation +/-0.01s to the scheduled time.\n     * Or give it a time value which it will randomize by.\n     */\n    get humanize() {\n        return this._event.humanize;\n    }\n    set humanize(variation) {\n        this._event.humanize = variation;\n    }\n    /**\n     * The probably of the callback being invoked.\n     */\n    get probability() {\n        return this._event.probability;\n    }\n    set probability(prob) {\n        this._event.probability = prob;\n    }\n    /**\n     * Muting the Loop means that no callbacks are invoked.\n     */\n    get mute() {\n        return this._event.mute;\n    }\n    set mute(mute) {\n        this._event.mute = mute;\n    }\n    /**\n     * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n     */\n    get iterations() {\n        if (this._event.loop === true) {\n            return Infinity;\n        }\n        else {\n            return this._event.loop;\n        }\n    }\n    set iterations(iters) {\n        if (iters === Infinity) {\n            this._event.loop = true;\n        }\n        else {\n            this._event.loop = iters;\n        }\n    }\n    dispose() {\n        super.dispose();\n        this._event.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Loop.js.map"]},"metadata":{},"sourceType":"module"}