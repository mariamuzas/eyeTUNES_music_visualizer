{"ast":null,"code":"import { Delay } from \"../core/context/Delay\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { FeedbackEffect } from \"./FeedbackEffect\";\n/**\n * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.\n *\n * @param delayTime The delay applied to the incoming signal.\n * @param feedback The amount of the effected signal which is fed back through the delay.\n * @example\n * const feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toDestination();\n * const tom = new Tone.MembraneSynth({\n * \toctaves: 4,\n * \tpitchDecay: 0.1\n * }).connect(feedbackDelay);\n * tom.triggerAttackRelease(\"A2\", \"32n\");\n * @category Effect\n */\n\nexport class FeedbackDelay extends FeedbackEffect {\n  constructor() {\n    super(optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n    this.name = \"FeedbackDelay\";\n    const options = optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n    this._delayNode = new Delay({\n      context: this.context,\n      delayTime: options.delayTime,\n      maxDelay: options.maxDelay\n    });\n    this.delayTime = this._delayNode.delayTime; // connect it up\n\n    this.connectEffect(this._delayNode);\n    readOnly(this, \"delayTime\");\n  }\n\n  static getDefaults() {\n    return Object.assign(FeedbackEffect.getDefaults(), {\n      delayTime: 0.25,\n      maxDelay: 1\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._delayNode.dispose();\n\n    this.delayTime.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/effect/FeedbackDelay.ts"],"names":[],"mappings":"AAAA,SAAS,KAAT,QAAsB,uBAAtB;AAGA,SAAS,oBAAT,QAAqC,uBAArC;AACA,SAAS,QAAT,QAAyB,wBAAzB;AACA,SAAS,cAAT,QAAsD,kBAAtD;AAOA;;;;;;;;;;;;;AAaG;;AACH,OAAM,MAAO,aAAP,SAA6B,cAA7B,CAAiE;AAgBtE,EAAA,WAAA,GAAA;AAEC,UAAM,oBAAoB,CAAC,aAAa,CAAC,WAAd,EAAD,EAA8B,SAA9B,EAAyC,CAAC,WAAD,EAAc,UAAd,CAAzC,CAA1B;AAhBQ,SAAA,IAAA,GAAe,eAAf;AAiBR,UAAM,OAAO,GAAG,oBAAoB,CAAC,aAAa,CAAC,WAAd,EAAD,EAA8B,SAA9B,EAAyC,CAAC,WAAD,EAAc,UAAd,CAAzC,CAApC;AAEA,SAAK,UAAL,GAAkB,IAAI,KAAJ,CAAU;AAC3B,MAAA,OAAO,EAAE,KAAK,OADa;AAE3B,MAAA,SAAS,EAAE,OAAO,CAAC,SAFQ;AAG3B,MAAA,QAAQ,EAAE,OAAO,CAAC;AAHS,KAAV,CAAlB;AAKA,SAAK,SAAL,GAAiB,KAAK,UAAL,CAAgB,SAAjC,CAVD,CAYC;;AACA,SAAK,aAAL,CAAmB,KAAK,UAAxB;AACA,IAAA,QAAQ,CAAC,IAAD,EAAO,WAAP,CAAR;AACA;;AAED,SAAO,WAAP,GAAkB;AACjB,WAAO,MAAM,CAAC,MAAP,CAAc,cAAc,CAAC,WAAf,EAAd,EAA4C;AAClD,MAAA,SAAS,EAAE,IADuC;AAElD,MAAA,QAAQ,EAAE;AAFwC,KAA5C,CAAP;AAIA;;AAED,EAAA,OAAO,GAAA;AACN,UAAM,OAAN;;AACA,SAAK,UAAL,CAAgB,OAAhB;;AACA,SAAK,SAAL,CAAe,OAAf;AACA,WAAO,IAAP;AACA;;AA7CqE","sourceRoot":"","sourcesContent":["import { Delay } from \"../core/context/Delay\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { FeedbackEffect } from \"./FeedbackEffect\";\n/**\n * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.\n *\n * @param delayTime The delay applied to the incoming signal.\n * @param feedback The amount of the effected signal which is fed back through the delay.\n * @example\n * const feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toDestination();\n * const tom = new Tone.MembraneSynth({\n * \toctaves: 4,\n * \tpitchDecay: 0.1\n * }).connect(feedbackDelay);\n * tom.triggerAttackRelease(\"A2\", \"32n\");\n * @category Effect\n */\nexport class FeedbackDelay extends FeedbackEffect {\n    constructor() {\n        super(optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n        this.name = \"FeedbackDelay\";\n        const options = optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n        this._delayNode = new Delay({\n            context: this.context,\n            delayTime: options.delayTime,\n            maxDelay: options.maxDelay,\n        });\n        this.delayTime = this._delayNode.delayTime;\n        // connect it up\n        this.connectEffect(this._delayNode);\n        readOnly(this, \"delayTime\");\n    }\n    static getDefaults() {\n        return Object.assign(FeedbackEffect.getDefaults(), {\n            delayTime: 0.25,\n            maxDelay: 1,\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._delayNode.dispose();\n        this.delayTime.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=FeedbackDelay.js.map"]},"metadata":{},"sourceType":"module"}