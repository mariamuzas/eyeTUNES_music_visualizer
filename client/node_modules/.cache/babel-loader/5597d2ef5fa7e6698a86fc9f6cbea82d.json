{"ast":null,"code":"import { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\n\nexport class Transport extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Transport.getDefaults(), arguments));\n    this.name = \"Transport\"; //-------------------------------------\n    // \tLOOPING\n    //-------------------------------------\n\n    /**\n     * If the transport loops or not.\n     */\n\n    this._loop = new TimelineValue(false);\n    /**\n     * The loop start position in ticks\n     */\n\n    this._loopStart = 0;\n    /**\n     * The loop end position in ticks\n     */\n\n    this._loopEnd = 0; //-------------------------------------\n    // \tTIMELINE EVENTS\n    //-------------------------------------\n\n    /**\n     * All the events in an object to keep track by ID\n     */\n\n    this._scheduledEvents = {};\n    /**\n     * The scheduled events.\n     */\n\n    this._timeline = new Timeline();\n    /**\n     * Repeated events\n     */\n\n    this._repeatedEvents = new IntervalTimeline();\n    /**\n     * All of the synced Signals\n     */\n\n    this._syncedSignals = [];\n    /**\n     * The swing amount\n     */\n\n    this._swingAmount = 0;\n    const options = optionsFromArguments(Transport.getDefaults(), arguments); // CLOCK/TEMPO\n\n    this._ppq = options.ppq;\n    this._clock = new Clock({\n      callback: this._processTick.bind(this),\n      context: this.context,\n      frequency: 0,\n      units: \"bpm\"\n    });\n\n    this._bindClockEvents();\n\n    this.bpm = this._clock.frequency;\n    this._clock.frequency.multiplier = options.ppq;\n    this.bpm.setValueAtTime(options.bpm, 0);\n    readOnly(this, \"bpm\");\n    this._timeSignature = options.timeSignature; // SWING\n\n    this._swingTicks = options.ppq / 2; // 8n\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      bpm: 120,\n      loopEnd: \"4m\",\n      loopStart: 0,\n      ppq: 192,\n      swing: 0,\n      swingSubdivision: \"8n\",\n      timeSignature: 4\n    });\n  } //-------------------------------------\n  // \tTICKS\n  //-------------------------------------\n\n  /**\n   * called on every tick\n   * @param  tickTime clock relative tick time\n   */\n\n\n  _processTick(tickTime, ticks) {\n    // handle swing\n    if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat\n    ticks % (this._swingTicks * 2) !== 0) {\n      // add some swing\n      const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n\n      const amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\n      tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n    } // do the loop test\n\n\n    if (this._loop.get(tickTime)) {\n      if (ticks >= this._loopEnd) {\n        this.emit(\"loopEnd\", tickTime);\n\n        this._clock.setTicksAtTime(this._loopStart, tickTime);\n\n        ticks = this._loopStart;\n        this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n        this.emit(\"loop\", tickTime);\n      }\n    } // invoke the timeline events scheduled on this tick\n\n\n    this._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n  } //-------------------------------------\n  // \tSCHEDULABLE EVENTS\n  //-------------------------------------\n\n  /**\n   * Schedule an event along the timeline.\n   * @param callback The callback to be invoked at the time.\n   * @param time The time to invoke the callback at.\n   * @return The id of the event which can be used for canceling the event.\n   * @example\n   * // schedule an event on the 16th measure\n   * Tone.Transport.schedule((time) => {\n   * \t// invoked on measure 16\n   * \tconsole.log(\"measure 16!\");\n   * }, \"16:0:0\");\n   */\n\n\n  schedule(callback, time) {\n    const event = new TransportEvent(this, {\n      callback,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  }\n  /**\n   * Schedule a repeated event along the timeline. The event will fire\n   * at the `interval` starting at the `startTime` and for the specified\n   * `duration`.\n   * @param  callback   The callback to invoke.\n   * @param  interval   The duration between successive callbacks. Must be a positive number.\n   * @param  startTime  When along the timeline the events should start being invoked.\n   * @param  duration How long the event should repeat.\n   * @return  The ID of the scheduled event. Use this to cancel the event.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // a callback invoked every eighth note after the first measure\n   * Tone.Transport.scheduleRepeat((time) => {\n   * \tosc.start(time).stop(time + 0.1);\n   * }, \"8n\", \"1m\");\n   */\n\n\n  scheduleRepeat(callback, interval, startTime, duration = Infinity) {\n    const event = new TransportRepeatEvent(this, {\n      callback,\n      duration: new TimeClass(this.context, duration).toTicks(),\n      interval: new TimeClass(this.context, interval).toTicks(),\n      time: new TransportTimeClass(this.context, startTime).toTicks()\n    }); // kick it off if the Transport is started\n    // @ts-ignore\n\n    return this._addEvent(event, this._repeatedEvents);\n  }\n  /**\n   * Schedule an event that will be removed after it is invoked.\n   * @param callback The callback to invoke once.\n   * @param time The time the callback should be invoked.\n   * @returns The ID of the scheduled event.\n   */\n\n\n  scheduleOnce(callback, time) {\n    const event = new TransportEvent(this, {\n      callback,\n      once: true,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  }\n  /**\n   * Clear the passed in event id from the timeline\n   * @param eventId The id of the event.\n   */\n\n\n  clear(eventId) {\n    if (this._scheduledEvents.hasOwnProperty(eventId)) {\n      const item = this._scheduledEvents[eventId.toString()];\n\n      item.timeline.remove(item.event);\n      item.event.dispose();\n      delete this._scheduledEvents[eventId.toString()];\n    }\n\n    return this;\n  }\n  /**\n   * Add an event to the correct timeline. Keep track of the\n   * timeline it was added to.\n   * @returns the event id which was just added\n   */\n\n\n  _addEvent(event, timeline) {\n    this._scheduledEvents[event.id.toString()] = {\n      event,\n      timeline\n    };\n    timeline.add(event);\n    return event.id;\n  }\n  /**\n   * Remove scheduled events from the timeline after\n   * the given time. Repeated events will be removed\n   * if their startTime is after the given time\n   * @param after Clear all events after this time.\n   */\n\n\n  cancel(after = 0) {\n    const computedAfter = this.toTicks(after);\n\n    this._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\n    this._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\n    return this;\n  } //-------------------------------------\n  // \tSTART/STOP/PAUSE\n  //-------------------------------------\n\n  /**\n   * Bind start/stop/pause events from the clock and emit them.\n   */\n\n\n  _bindClockEvents() {\n    this._clock.on(\"start\", (time, offset) => {\n      offset = new TicksClass(this.context, offset).toSeconds();\n      this.emit(\"start\", time, offset);\n    });\n\n    this._clock.on(\"stop\", time => {\n      this.emit(\"stop\", time);\n    });\n\n    this._clock.on(\"pause\", time => {\n      this.emit(\"pause\", time);\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n   */\n\n\n  get state() {\n    return this._clock.getStateAtTime(this.now());\n  }\n  /**\n   * Start the transport and all sources synced to the transport.\n   * @param  time The time when the transport should start.\n   * @param  offset The timeline offset to start the transport.\n   * @example\n   * // start the transport in one second starting at beginning of the 5th measure.\n   * Tone.Transport.start(\"+1\", \"4:0:0\");\n   */\n\n\n  start(time, offset) {\n    let offsetTicks;\n\n    if (isDefined(offset)) {\n      offsetTicks = this.toTicks(offset);\n    } // start the clock\n\n\n    this._clock.start(time, offsetTicks);\n\n    return this;\n  }\n  /**\n   * Stop the transport and all sources synced to the transport.\n   * @param time The time when the transport should stop.\n   * @example\n   * Tone.Transport.stop();\n   */\n\n\n  stop(time) {\n    this._clock.stop(time);\n\n    return this;\n  }\n  /**\n   * Pause the transport and all sources synced to the transport.\n   */\n\n\n  pause(time) {\n    this._clock.pause(time);\n\n    return this;\n  }\n  /**\n   * Toggle the current state of the transport. If it is\n   * started, it will stop it, otherwise it will start the Transport.\n   * @param  time The time of the event\n   */\n\n\n  toggle(time) {\n    time = this.toSeconds(time);\n\n    if (this._clock.getStateAtTime(time) !== \"started\") {\n      this.start(time);\n    } else {\n      this.stop(time);\n    }\n\n    return this;\n  } //-------------------------------------\n  // \tSETTERS/GETTERS\n  //-------------------------------------\n\n  /**\n   * The time signature as just the numerator over 4.\n   * For example 4/4 would be just 4 and 6/8 would be 3.\n   * @example\n   * // common time\n   * Tone.Transport.timeSignature = 4;\n   * // 7/8\n   * Tone.Transport.timeSignature = [7, 8];\n   * // this will be reduced to a single number\n   * Tone.Transport.timeSignature; // returns 3.5\n   */\n\n\n  get timeSignature() {\n    return this._timeSignature;\n  }\n\n  set timeSignature(timeSig) {\n    if (isArray(timeSig)) {\n      timeSig = timeSig[0] / timeSig[1] * 4;\n    }\n\n    this._timeSignature = timeSig;\n  }\n  /**\n   * When the Transport.loop = true, this is the starting position of the loop.\n   */\n\n\n  get loopStart() {\n    return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n  }\n\n  set loopStart(startPosition) {\n    this._loopStart = this.toTicks(startPosition);\n  }\n  /**\n   * When the Transport.loop = true, this is the ending position of the loop.\n   */\n\n\n  get loopEnd() {\n    return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n  }\n\n  set loopEnd(endPosition) {\n    this._loopEnd = this.toTicks(endPosition);\n  }\n  /**\n   * If the transport loops or not.\n   */\n\n\n  get loop() {\n    return this._loop.get(this.now());\n  }\n\n  set loop(loop) {\n    this._loop.set(loop, this.now());\n  }\n  /**\n   * Set the loop start and stop at the same time.\n   * @example\n   * // loop over the first measure\n   * Tone.Transport.setLoopPoints(0, \"1m\");\n   * Tone.Transport.loop = true;\n   */\n\n\n  setLoopPoints(startPosition, endPosition) {\n    this.loopStart = startPosition;\n    this.loopEnd = endPosition;\n    return this;\n  }\n  /**\n   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n   */\n\n\n  get swing() {\n    return this._swingAmount;\n  }\n\n  set swing(amount) {\n    // scale the values to a normal range\n    this._swingAmount = amount;\n  }\n  /**\n   * Set the subdivision which the swing will be applied to.\n   * The default value is an 8th note. Value must be less\n   * than a quarter note.\n   */\n\n\n  get swingSubdivision() {\n    return new TicksClass(this.context, this._swingTicks).toNotation();\n  }\n\n  set swingSubdivision(subdivision) {\n    this._swingTicks = this.toTicks(subdivision);\n  }\n  /**\n   * The Transport's position in Bars:Beats:Sixteenths.\n   * Setting the value will jump to that position right away.\n   */\n\n\n  get position() {\n    const now = this.now();\n\n    const ticks = this._clock.getTicksAtTime(now);\n\n    return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n  }\n\n  set position(progress) {\n    const ticks = this.toTicks(progress);\n    this.ticks = ticks;\n  }\n  /**\n   * The Transport's position in seconds\n   * Setting the value will jump to that position right away.\n   */\n\n\n  get seconds() {\n    return this._clock.seconds;\n  }\n\n  set seconds(s) {\n    const now = this.now();\n\n    const ticks = this._clock.frequency.timeToTicks(s, now);\n\n    this.ticks = ticks;\n  }\n  /**\n   * The Transport's loop position as a normalized value. Always\n   * returns 0 if the transport if loop is not true.\n   */\n\n\n  get progress() {\n    if (this.loop) {\n      const now = this.now();\n\n      const ticks = this._clock.getTicksAtTime(now);\n\n      return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The transports current tick position.\n   */\n\n\n  get ticks() {\n    return this._clock.ticks;\n  }\n\n  set ticks(t) {\n    if (this._clock.ticks !== t) {\n      const now = this.now(); // stop everything synced to the transport\n\n      if (this.state === \"started\") {\n        const ticks = this._clock.getTicksAtTime(now); // schedule to start on the next tick, #573\n\n\n        const time = this._clock.getTimeOfTick(Math.ceil(ticks));\n\n        this.emit(\"stop\", time);\n\n        this._clock.setTicksAtTime(t, time); // restart it with the new time\n\n\n        this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n      } else {\n        this._clock.setTicksAtTime(t, now);\n      }\n    }\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n\n\n  getTicksAtTime(time) {\n    return Math.round(this._clock.getTicksAtTime(time));\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    return this._clock.getSecondsAtTime(time);\n  }\n  /**\n   * Pulses Per Quarter note. This is the smallest resolution\n   * the Transport timing supports. This should be set once\n   * on initialization and not set again. Changing this value\n   * after other objects have been created can cause problems.\n   */\n\n\n  get PPQ() {\n    return this._clock.frequency.multiplier;\n  }\n\n  set PPQ(ppq) {\n    this._clock.frequency.multiplier = ppq;\n  } //-------------------------------------\n  // \tSYNCING\n  //-------------------------------------\n\n  /**\n   * Returns the time aligned to the next subdivision\n   * of the Transport. If the Transport is not started,\n   * it will return 0.\n   * Note: this will not work precisely during tempo ramps.\n   * @param  subdivision  The subdivision to quantize to\n   * @return  The context time of the next subdivision.\n   * @example\n   * // the transport must be started, otherwise returns 0\n   * Tone.Transport.start();\n   * Tone.Transport.nextSubdivision(\"4n\");\n   */\n\n\n  nextSubdivision(subdivision) {\n    subdivision = this.toTicks(subdivision);\n\n    if (this.state !== \"started\") {\n      // if the transport's not started, return 0\n      return 0;\n    } else {\n      const now = this.now(); // the remainder of the current ticks and the subdivision\n\n      const transportPos = this.getTicksAtTime(now);\n      const remainingTicks = subdivision - transportPos % subdivision;\n      return this._clock.nextTickTime(remainingTicks, now);\n    }\n  }\n  /**\n   * Attaches the signal to the tempo control signal so that\n   * any changes in the tempo will change the signal in the same\n   * ratio.\n   *\n   * @param signal\n   * @param ratio Optionally pass in the ratio between the two signals.\n   * \t\t\tOtherwise it will be computed based on their current values.\n   */\n\n\n  syncSignal(signal, ratio) {\n    if (!ratio) {\n      // get the sync ratio\n      const now = this.now();\n\n      if (signal.getValueAtTime(now) !== 0) {\n        const bpm = this.bpm.getValueAtTime(now);\n        const computedFreq = 1 / (60 / bpm / this.PPQ);\n        ratio = signal.getValueAtTime(now) / computedFreq;\n      } else {\n        ratio = 0;\n      }\n    }\n\n    const ratioSignal = new Gain(ratio); // @ts-ignore\n\n    this.bpm.connect(ratioSignal); // @ts-ignore\n\n    ratioSignal.connect(signal._param);\n\n    this._syncedSignals.push({\n      initial: signal.value,\n      ratio: ratioSignal,\n      signal\n    });\n\n    signal.value = 0;\n    return this;\n  }\n  /**\n   * Unsyncs a previously synced signal from the transport's control.\n   * See Transport.syncSignal.\n   */\n\n\n  unsyncSignal(signal) {\n    for (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n      const syncedSignal = this._syncedSignals[i];\n\n      if (syncedSignal.signal === signal) {\n        syncedSignal.ratio.dispose();\n        syncedSignal.signal.value = syncedSignal.initial;\n\n        this._syncedSignals.splice(i, 1);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._clock.dispose();\n\n    writable(this, \"bpm\");\n\n    this._timeline.dispose();\n\n    this._repeatedEvents.dispose();\n\n    return this;\n  }\n\n}\nEmitter.mixin(Transport); //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n  context.transport = new Transport({\n    context\n  });\n});\nonContextClose(context => {\n  context.transport.dispose();\n});","map":{"version":3,"sources":["../../../../Tone/core/clock/Transport.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\nexport class Transport extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Transport.getDefaults(), arguments));\n        this.name = \"Transport\";\n        //-------------------------------------\n        // \tLOOPING\n        //-------------------------------------\n        /**\n         * If the transport loops or not.\n         */\n        this._loop = new TimelineValue(false);\n        /**\n         * The loop start position in ticks\n         */\n        this._loopStart = 0;\n        /**\n         * The loop end position in ticks\n         */\n        this._loopEnd = 0;\n        //-------------------------------------\n        // \tTIMELINE EVENTS\n        //-------------------------------------\n        /**\n         * All the events in an object to keep track by ID\n         */\n        this._scheduledEvents = {};\n        /**\n         * The scheduled events.\n         */\n        this._timeline = new Timeline();\n        /**\n         * Repeated events\n         */\n        this._repeatedEvents = new IntervalTimeline();\n        /**\n         * All of the synced Signals\n         */\n        this._syncedSignals = [];\n        /**\n         * The swing amount\n         */\n        this._swingAmount = 0;\n        const options = optionsFromArguments(Transport.getDefaults(), arguments);\n        // CLOCK/TEMPO\n        this._ppq = options.ppq;\n        this._clock = new Clock({\n            callback: this._processTick.bind(this),\n            context: this.context,\n            frequency: 0,\n            units: \"bpm\",\n        });\n        this._bindClockEvents();\n        this.bpm = this._clock.frequency;\n        this._clock.frequency.multiplier = options.ppq;\n        this.bpm.setValueAtTime(options.bpm, 0);\n        readOnly(this, \"bpm\");\n        this._timeSignature = options.timeSignature;\n        // SWING\n        this._swingTicks = options.ppq / 2; // 8n\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            bpm: 120,\n            loopEnd: \"4m\",\n            loopStart: 0,\n            ppq: 192,\n            swing: 0,\n            swingSubdivision: \"8n\",\n            timeSignature: 4,\n        });\n    }\n    //-------------------------------------\n    // \tTICKS\n    //-------------------------------------\n    /**\n     * called on every tick\n     * @param  tickTime clock relative tick time\n     */\n    _processTick(tickTime, ticks) {\n        // handle swing\n        if (this._swingAmount > 0 &&\n            ticks % this._ppq !== 0 && // not on a downbeat\n            ticks % (this._swingTicks * 2) !== 0) {\n            // add some swing\n            const progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n            const amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n            tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n        }\n        // do the loop test\n        if (this._loop.get(tickTime)) {\n            if (ticks >= this._loopEnd) {\n                this.emit(\"loopEnd\", tickTime);\n                this._clock.setTicksAtTime(this._loopStart, tickTime);\n                ticks = this._loopStart;\n                this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n                this.emit(\"loop\", tickTime);\n            }\n        }\n        // invoke the timeline events scheduled on this tick\n        this._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n    }\n    //-------------------------------------\n    // \tSCHEDULABLE EVENTS\n    //-------------------------------------\n    /**\n     * Schedule an event along the timeline.\n     * @param callback The callback to be invoked at the time.\n     * @param time The time to invoke the callback at.\n     * @return The id of the event which can be used for canceling the event.\n     * @example\n     * // schedule an event on the 16th measure\n     * Tone.Transport.schedule((time) => {\n     * \t// invoked on measure 16\n     * \tconsole.log(\"measure 16!\");\n     * }, \"16:0:0\");\n     */\n    schedule(callback, time) {\n        const event = new TransportEvent(this, {\n            callback,\n            time: new TransportTimeClass(this.context, time).toTicks(),\n        });\n        return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Schedule a repeated event along the timeline. The event will fire\n     * at the `interval` starting at the `startTime` and for the specified\n     * `duration`.\n     * @param  callback   The callback to invoke.\n     * @param  interval   The duration between successive callbacks. Must be a positive number.\n     * @param  startTime  When along the timeline the events should start being invoked.\n     * @param  duration How long the event should repeat.\n     * @return  The ID of the scheduled event. Use this to cancel the event.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // a callback invoked every eighth note after the first measure\n     * Tone.Transport.scheduleRepeat((time) => {\n     * \tosc.start(time).stop(time + 0.1);\n     * }, \"8n\", \"1m\");\n     */\n    scheduleRepeat(callback, interval, startTime, duration = Infinity) {\n        const event = new TransportRepeatEvent(this, {\n            callback,\n            duration: new TimeClass(this.context, duration).toTicks(),\n            interval: new TimeClass(this.context, interval).toTicks(),\n            time: new TransportTimeClass(this.context, startTime).toTicks(),\n        });\n        // kick it off if the Transport is started\n        // @ts-ignore\n        return this._addEvent(event, this._repeatedEvents);\n    }\n    /**\n     * Schedule an event that will be removed after it is invoked.\n     * @param callback The callback to invoke once.\n     * @param time The time the callback should be invoked.\n     * @returns The ID of the scheduled event.\n     */\n    scheduleOnce(callback, time) {\n        const event = new TransportEvent(this, {\n            callback,\n            once: true,\n            time: new TransportTimeClass(this.context, time).toTicks(),\n        });\n        return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Clear the passed in event id from the timeline\n     * @param eventId The id of the event.\n     */\n    clear(eventId) {\n        if (this._scheduledEvents.hasOwnProperty(eventId)) {\n            const item = this._scheduledEvents[eventId.toString()];\n            item.timeline.remove(item.event);\n            item.event.dispose();\n            delete this._scheduledEvents[eventId.toString()];\n        }\n        return this;\n    }\n    /**\n     * Add an event to the correct timeline. Keep track of the\n     * timeline it was added to.\n     * @returns the event id which was just added\n     */\n    _addEvent(event, timeline) {\n        this._scheduledEvents[event.id.toString()] = {\n            event,\n            timeline,\n        };\n        timeline.add(event);\n        return event.id;\n    }\n    /**\n     * Remove scheduled events from the timeline after\n     * the given time. Repeated events will be removed\n     * if their startTime is after the given time\n     * @param after Clear all events after this time.\n     */\n    cancel(after = 0) {\n        const computedAfter = this.toTicks(after);\n        this._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n        this._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n        return this;\n    }\n    //-------------------------------------\n    // \tSTART/STOP/PAUSE\n    //-------------------------------------\n    /**\n     * Bind start/stop/pause events from the clock and emit them.\n     */\n    _bindClockEvents() {\n        this._clock.on(\"start\", (time, offset) => {\n            offset = new TicksClass(this.context, offset).toSeconds();\n            this.emit(\"start\", time, offset);\n        });\n        this._clock.on(\"stop\", (time) => {\n            this.emit(\"stop\", time);\n        });\n        this._clock.on(\"pause\", (time) => {\n            this.emit(\"pause\", time);\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n     */\n    get state() {\n        return this._clock.getStateAtTime(this.now());\n    }\n    /**\n     * Start the transport and all sources synced to the transport.\n     * @param  time The time when the transport should start.\n     * @param  offset The timeline offset to start the transport.\n     * @example\n     * // start the transport in one second starting at beginning of the 5th measure.\n     * Tone.Transport.start(\"+1\", \"4:0:0\");\n     */\n    start(time, offset) {\n        let offsetTicks;\n        if (isDefined(offset)) {\n            offsetTicks = this.toTicks(offset);\n        }\n        // start the clock\n        this._clock.start(time, offsetTicks);\n        return this;\n    }\n    /**\n     * Stop the transport and all sources synced to the transport.\n     * @param time The time when the transport should stop.\n     * @example\n     * Tone.Transport.stop();\n     */\n    stop(time) {\n        this._clock.stop(time);\n        return this;\n    }\n    /**\n     * Pause the transport and all sources synced to the transport.\n     */\n    pause(time) {\n        this._clock.pause(time);\n        return this;\n    }\n    /**\n     * Toggle the current state of the transport. If it is\n     * started, it will stop it, otherwise it will start the Transport.\n     * @param  time The time of the event\n     */\n    toggle(time) {\n        time = this.toSeconds(time);\n        if (this._clock.getStateAtTime(time) !== \"started\") {\n            this.start(time);\n        }\n        else {\n            this.stop(time);\n        }\n        return this;\n    }\n    //-------------------------------------\n    // \tSETTERS/GETTERS\n    //-------------------------------------\n    /**\n     * The time signature as just the numerator over 4.\n     * For example 4/4 would be just 4 and 6/8 would be 3.\n     * @example\n     * // common time\n     * Tone.Transport.timeSignature = 4;\n     * // 7/8\n     * Tone.Transport.timeSignature = [7, 8];\n     * // this will be reduced to a single number\n     * Tone.Transport.timeSignature; // returns 3.5\n     */\n    get timeSignature() {\n        return this._timeSignature;\n    }\n    set timeSignature(timeSig) {\n        if (isArray(timeSig)) {\n            timeSig = (timeSig[0] / timeSig[1]) * 4;\n        }\n        this._timeSignature = timeSig;\n    }\n    /**\n     * When the Transport.loop = true, this is the starting position of the loop.\n     */\n    get loopStart() {\n        return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n    }\n    set loopStart(startPosition) {\n        this._loopStart = this.toTicks(startPosition);\n    }\n    /**\n     * When the Transport.loop = true, this is the ending position of the loop.\n     */\n    get loopEnd() {\n        return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n    }\n    set loopEnd(endPosition) {\n        this._loopEnd = this.toTicks(endPosition);\n    }\n    /**\n     * If the transport loops or not.\n     */\n    get loop() {\n        return this._loop.get(this.now());\n    }\n    set loop(loop) {\n        this._loop.set(loop, this.now());\n    }\n    /**\n     * Set the loop start and stop at the same time.\n     * @example\n     * // loop over the first measure\n     * Tone.Transport.setLoopPoints(0, \"1m\");\n     * Tone.Transport.loop = true;\n     */\n    setLoopPoints(startPosition, endPosition) {\n        this.loopStart = startPosition;\n        this.loopEnd = endPosition;\n        return this;\n    }\n    /**\n     * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n     */\n    get swing() {\n        return this._swingAmount;\n    }\n    set swing(amount) {\n        // scale the values to a normal range\n        this._swingAmount = amount;\n    }\n    /**\n     * Set the subdivision which the swing will be applied to.\n     * The default value is an 8th note. Value must be less\n     * than a quarter note.\n     */\n    get swingSubdivision() {\n        return new TicksClass(this.context, this._swingTicks).toNotation();\n    }\n    set swingSubdivision(subdivision) {\n        this._swingTicks = this.toTicks(subdivision);\n    }\n    /**\n     * The Transport's position in Bars:Beats:Sixteenths.\n     * Setting the value will jump to that position right away.\n     */\n    get position() {\n        const now = this.now();\n        const ticks = this._clock.getTicksAtTime(now);\n        return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n    }\n    set position(progress) {\n        const ticks = this.toTicks(progress);\n        this.ticks = ticks;\n    }\n    /**\n     * The Transport's position in seconds\n     * Setting the value will jump to that position right away.\n     */\n    get seconds() {\n        return this._clock.seconds;\n    }\n    set seconds(s) {\n        const now = this.now();\n        const ticks = this._clock.frequency.timeToTicks(s, now);\n        this.ticks = ticks;\n    }\n    /**\n     * The Transport's loop position as a normalized value. Always\n     * returns 0 if the transport if loop is not true.\n     */\n    get progress() {\n        if (this.loop) {\n            const now = this.now();\n            const ticks = this._clock.getTicksAtTime(now);\n            return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The transports current tick position.\n     */\n    get ticks() {\n        return this._clock.ticks;\n    }\n    set ticks(t) {\n        if (this._clock.ticks !== t) {\n            const now = this.now();\n            // stop everything synced to the transport\n            if (this.state === \"started\") {\n                const ticks = this._clock.getTicksAtTime(now);\n                // schedule to start on the next tick, #573\n                const time = this._clock.getTimeOfTick(Math.ceil(ticks));\n                this.emit(\"stop\", time);\n                this._clock.setTicksAtTime(t, time);\n                // restart it with the new time\n                this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n            }\n            else {\n                this._clock.setTicksAtTime(t, now);\n            }\n        }\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    getTicksAtTime(time) {\n        return Math.round(this._clock.getTicksAtTime(time));\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        return this._clock.getSecondsAtTime(time);\n    }\n    /**\n     * Pulses Per Quarter note. This is the smallest resolution\n     * the Transport timing supports. This should be set once\n     * on initialization and not set again. Changing this value\n     * after other objects have been created can cause problems.\n     */\n    get PPQ() {\n        return this._clock.frequency.multiplier;\n    }\n    set PPQ(ppq) {\n        this._clock.frequency.multiplier = ppq;\n    }\n    //-------------------------------------\n    // \tSYNCING\n    //-------------------------------------\n    /**\n     * Returns the time aligned to the next subdivision\n     * of the Transport. If the Transport is not started,\n     * it will return 0.\n     * Note: this will not work precisely during tempo ramps.\n     * @param  subdivision  The subdivision to quantize to\n     * @return  The context time of the next subdivision.\n     * @example\n     * // the transport must be started, otherwise returns 0\n     * Tone.Transport.start();\n     * Tone.Transport.nextSubdivision(\"4n\");\n     */\n    nextSubdivision(subdivision) {\n        subdivision = this.toTicks(subdivision);\n        if (this.state !== \"started\") {\n            // if the transport's not started, return 0\n            return 0;\n        }\n        else {\n            const now = this.now();\n            // the remainder of the current ticks and the subdivision\n            const transportPos = this.getTicksAtTime(now);\n            const remainingTicks = subdivision - transportPos % subdivision;\n            return this._clock.nextTickTime(remainingTicks, now);\n        }\n    }\n    /**\n     * Attaches the signal to the tempo control signal so that\n     * any changes in the tempo will change the signal in the same\n     * ratio.\n     *\n     * @param signal\n     * @param ratio Optionally pass in the ratio between the two signals.\n     * \t\t\tOtherwise it will be computed based on their current values.\n     */\n    syncSignal(signal, ratio) {\n        if (!ratio) {\n            // get the sync ratio\n            const now = this.now();\n            if (signal.getValueAtTime(now) !== 0) {\n                const bpm = this.bpm.getValueAtTime(now);\n                const computedFreq = 1 / (60 / bpm / this.PPQ);\n                ratio = signal.getValueAtTime(now) / computedFreq;\n            }\n            else {\n                ratio = 0;\n            }\n        }\n        const ratioSignal = new Gain(ratio);\n        // @ts-ignore\n        this.bpm.connect(ratioSignal);\n        // @ts-ignore\n        ratioSignal.connect(signal._param);\n        this._syncedSignals.push({\n            initial: signal.value,\n            ratio: ratioSignal,\n            signal,\n        });\n        signal.value = 0;\n        return this;\n    }\n    /**\n     * Unsyncs a previously synced signal from the transport's control.\n     * See Transport.syncSignal.\n     */\n    unsyncSignal(signal) {\n        for (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n            const syncedSignal = this._syncedSignals[i];\n            if (syncedSignal.signal === signal) {\n                syncedSignal.ratio.dispose();\n                syncedSignal.signal.value = syncedSignal.initial;\n                this._syncedSignals.splice(i, 1);\n            }\n        }\n        return this;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._clock.dispose();\n        writable(this, \"bpm\");\n        this._timeline.dispose();\n        this._repeatedEvents.dispose();\n        return this;\n    }\n}\nEmitter.mixin(Transport);\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(context => {\n    context.transport = new Transport({ context });\n});\nonContextClose(context => {\n    context.transport.dispose();\n});\n//# sourceMappingURL=Transport.js.map"]},"metadata":{},"sourceType":"module"}