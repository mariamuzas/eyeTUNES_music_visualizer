{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst fmOsc = new Tone.FMOscillator({\n * \t\tfrequency: 200,\n * \t\ttype: \"square\",\n * \t\tmodulationType: \"triangle\",\n * \t\tharmonicity: 0.2,\n * \t\tmodulationIndex: 3\n * \t}).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\n\nexport class FMOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n    this.name = \"FMOscillator\";\n    /**\n     * the node where the modulation happens\n     */\n\n    this._modulationNode = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    const options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n    this._carrier = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: 0,\n      onstop: () => this.onstop(this),\n      phase: options.phase,\n      type: options.type\n    });\n    this.detune = this._carrier.detune;\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this._modulator = new Oscillator({\n      context: this.context,\n      phase: options.phase,\n      type: options.modulationType\n    });\n    this.harmonicity = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.harmonicity\n    });\n    this.modulationIndex = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.modulationIndex\n    }); // connections\n\n    this.frequency.connect(this._carrier.frequency);\n    this.frequency.chain(this.harmonicity, this._modulator.frequency);\n    this.frequency.chain(this.modulationIndex, this._modulationNode);\n\n    this._modulator.connect(this._modulationNode.gain);\n\n    this._modulationNode.connect(this._carrier.frequency);\n\n    this._carrier.connect(this.output);\n\n    this.detune.connect(this._modulator.detune);\n    readOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      harmonicity: 1,\n      modulationIndex: 2,\n      modulationType: \"square\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    this._modulator.start(time);\n\n    this._carrier.start(time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    this._modulator.stop(time);\n\n    this._carrier.stop(time);\n  }\n\n  _restart(time) {\n    this._modulator.restart(time);\n\n    this._carrier.restart(time);\n\n    return this;\n  }\n\n  get type() {\n    return this._carrier.type;\n  }\n\n  set type(type) {\n    this._carrier.type = type;\n  }\n\n  get baseType() {\n    return this._carrier.baseType;\n  }\n\n  set baseType(baseType) {\n    this._carrier.baseType = baseType;\n  }\n\n  get partialCount() {\n    return this._carrier.partialCount;\n  }\n\n  set partialCount(partialCount) {\n    this._carrier.partialCount = partialCount;\n  }\n  /**\n   * The type of the modulator oscillator\n   */\n\n\n  get modulationType() {\n    return this._modulator.type;\n  }\n\n  set modulationType(type) {\n    this._modulator.type = type;\n  }\n\n  get phase() {\n    return this._carrier.phase;\n  }\n\n  set phase(phase) {\n    this._carrier.phase = phase;\n    this._modulator.phase = phase;\n  }\n\n  get partials() {\n    return this._carrier.partials;\n  }\n\n  set partials(partials) {\n    this._carrier.partials = partials;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.harmonicity.dispose();\n\n    this._carrier.dispose();\n\n    this._modulator.dispose();\n\n    this._modulationNode.dispose();\n\n    this.modulationIndex.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/source/oscillator/FMOscillator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst fmOsc = new Tone.FMOscillator({\n * \t\tfrequency: 200,\n * \t\ttype: \"square\",\n * \t\tmodulationType: \"triangle\",\n * \t\tharmonicity: 0.2,\n * \t\tmodulationIndex: 3\n * \t}).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class FMOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n        this.name = \"FMOscillator\";\n        /**\n         * the node where the modulation happens\n         */\n        this._modulationNode = new Gain({\n            context: this.context,\n            gain: 0,\n        });\n        const options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n        this._carrier = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: 0,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n            type: options.type,\n        });\n        this.detune = this._carrier.detune;\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this._modulator = new Oscillator({\n            context: this.context,\n            phase: options.phase,\n            type: options.modulationType,\n        });\n        this.harmonicity = new Multiply({\n            context: this.context,\n            units: \"positive\",\n            value: options.harmonicity,\n        });\n        this.modulationIndex = new Multiply({\n            context: this.context,\n            units: \"positive\",\n            value: options.modulationIndex,\n        });\n        // connections\n        this.frequency.connect(this._carrier.frequency);\n        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n        this.frequency.chain(this.modulationIndex, this._modulationNode);\n        this._modulator.connect(this._modulationNode.gain);\n        this._modulationNode.connect(this._carrier.frequency);\n        this._carrier.connect(this.output);\n        this.detune.connect(this._modulator.detune);\n        readOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), {\n            harmonicity: 1,\n            modulationIndex: 2,\n            modulationType: \"square\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        this._modulator.start(time);\n        this._carrier.start(time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        this._modulator.stop(time);\n        this._carrier.stop(time);\n    }\n    _restart(time) {\n        this._modulator.restart(time);\n        this._carrier.restart(time);\n        return this;\n    }\n    get type() {\n        return this._carrier.type;\n    }\n    set type(type) {\n        this._carrier.type = type;\n    }\n    get baseType() {\n        return this._carrier.baseType;\n    }\n    set baseType(baseType) {\n        this._carrier.baseType = baseType;\n    }\n    get partialCount() {\n        return this._carrier.partialCount;\n    }\n    set partialCount(partialCount) {\n        this._carrier.partialCount = partialCount;\n    }\n    /**\n     * The type of the modulator oscillator\n     */\n    get modulationType() {\n        return this._modulator.type;\n    }\n    set modulationType(type) {\n        this._modulator.type = type;\n    }\n    get phase() {\n        return this._carrier.phase;\n    }\n    set phase(phase) {\n        this._carrier.phase = phase;\n        this._modulator.phase = phase;\n    }\n    get partials() {\n        return this._carrier.partials;\n    }\n    set partials(partials) {\n        this._carrier.partials = partials;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.frequency.dispose();\n        this.harmonicity.dispose();\n        this._carrier.dispose();\n        this._modulator.dispose();\n        this._modulationNode.dispose();\n        this.modulationIndex.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=FMOscillator.js.map"]},"metadata":{},"sourceType":"module"}