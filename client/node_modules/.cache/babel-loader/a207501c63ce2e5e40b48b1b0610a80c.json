{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport class UserMedia extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n    this.name = \"UserMedia\";\n    const options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    this._volume = this.output = new Volume({\n      context: this.context,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.mute = options.mute;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      volume: 0\n    });\n  }\n  /**\n   * Open the media stream. If a string is passed in, it is assumed\n   * to be the label or id of the stream, if a number is passed in,\n   * it is the input number of the stream.\n   * @param  labelOrId The label or id of the audio input media device.\n   *                   With no argument, the default stream is opened.\n   * @return The promise is resolved when the stream is open.\n   */\n\n\n  open(labelOrId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(UserMedia.supported, \"UserMedia is not supported\"); // close the previous stream\n\n      if (this.state === \"started\") {\n        this.close();\n      }\n\n      const devices = yield UserMedia.enumerateDevices();\n\n      if (isNumber(labelOrId)) {\n        this._device = devices[labelOrId];\n      } else {\n        this._device = devices.find(device => {\n          return device.label === labelOrId || device.deviceId === labelOrId;\n        }); // didn't find a matching device\n\n        if (!this._device && devices.length > 0) {\n          this._device = devices[0];\n        }\n\n        assert(isDefined(this._device), `No matching device ${labelOrId}`);\n      } // do getUserMedia\n\n\n      const constraints = {\n        audio: {\n          echoCancellation: false,\n          sampleRate: this.context.sampleRate,\n          noiseSuppression: false,\n          mozNoiseSuppression: false\n        }\n      };\n\n      if (this._device) {\n        // @ts-ignore\n        constraints.audio.deviceId = this._device.deviceId;\n      }\n\n      const stream = yield navigator.mediaDevices.getUserMedia(constraints); // start a new source only if the previous one is closed\n\n      if (!this._stream) {\n        this._stream = stream; // Wrap a MediaStreamSourceNode around the live input stream.\n\n        const mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node\n\n        connect(mediaStreamNode, this.output);\n        this._mediaStream = mediaStreamNode;\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Close the media stream\n   */\n\n\n  close() {\n    if (this._stream && this._mediaStream) {\n      this._stream.getAudioTracks().forEach(track => {\n        track.stop();\n      });\n\n      this._stream = undefined; // remove the old media stream\n\n      this._mediaStream.disconnect();\n\n      this._mediaStream = undefined;\n    }\n\n    this._device = undefined;\n    return this;\n  }\n  /**\n   * Returns a promise which resolves with the list of audio input devices available.\n   * @return The promise that is resolved with the devices\n   * @example\n   * Tone.UserMedia.enumerateDevices().then((devices) => {\n   * \t// print the device labels\n   * \tconsole.log(devices.map(device => device.label));\n   * });\n   */\n\n\n  static enumerateDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const allDevices = yield navigator.mediaDevices.enumerateDevices();\n      return allDevices.filter(device => {\n        return device.kind === \"audioinput\";\n      });\n    });\n  }\n  /**\n   * Returns the playback state of the source, \"started\" when the microphone is open\n   * and \"stopped\" when the mic is closed.\n   */\n\n\n  get state() {\n    return this._stream && this._stream.active ? \"started\" : \"stopped\";\n  }\n  /**\n   * Returns an identifier for the represented device that is\n   * persisted across sessions. It is un-guessable by other applications and\n   * unique to the origin of the calling application. It is reset when the\n   * user clears cookies (for Private Browsing, a different identifier is\n   * used that is not persisted across sessions). Returns undefined when the\n   * device is not open.\n   */\n\n\n  get deviceId() {\n    if (this._device) {\n      return this._device.deviceId;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Returns a group identifier. Two devices have the\n   * same group identifier if they belong to the same physical device.\n   * Returns null  when the device is not open.\n   */\n\n\n  get groupId() {\n    if (this._device) {\n      return this._device.groupId;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Returns a label describing this device (for example \"Built-in Microphone\").\n   * Returns undefined when the device is not open or label is not available\n   * because of permissions.\n   */\n\n\n  get label() {\n    if (this._device) {\n      return this._device.label;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const mic = new Tone.UserMedia();\n   * mic.open().then(() => {\n   * \t// promise resolves when input is available\n   * });\n   * // mute the output\n   * mic.mute = true;\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n\n  dispose() {\n    super.dispose();\n    this.close();\n\n    this._volume.dispose();\n\n    this.volume.dispose();\n    return this;\n  }\n  /**\n   * If getUserMedia is supported by the browser.\n   */\n\n\n  static get supported() {\n    return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/source/UserMedia.ts"],"names":[],"mappings":";AAAA,SAAS,OAAT,EAA8B,aAA9B,QAAyE,+BAAzE;AAEA,SAAS,MAAT,QAAuB,6BAAvB;AACA,SAAS,oBAAT,QAAqC,uBAArC;AACA,SAAS,MAAT,QAAuB,oBAAvB;AAEA,SAAS,QAAT,QAAyB,wBAAzB;AACA,SAAS,SAAT,EAAoB,QAApB,QAAoC,wBAApC;AAMA;;;;;;;;;;;;;;;;;;AAkBG;;AAEH,OAAM,MAAO,SAAP,SAAyB,aAAzB,CAAwD;AAqC7D,EAAA,WAAA,GAAA;AAEC,UAAM,oBAAoB,CAAC,SAAS,CAAC,WAAV,EAAD,EAA0B,SAA1B,EAAqC,CAAC,QAAD,CAArC,CAA1B;AArCQ,SAAA,IAAA,GAAe,WAAf;AAsCR,UAAM,OAAO,GAAG,oBAAoB,CAAC,SAAS,CAAC,WAAV,EAAD,EAA0B,SAA1B,EAAqC,CAAC,QAAD,CAArC,CAApC;AAEA,SAAK,OAAL,GAAe,KAAK,MAAL,GAAc,IAAI,MAAJ,CAAW;AACvC,MAAA,OAAO,EAAE,KAAK,OADyB;AAEvC,MAAA,MAAM,EAAE,OAAO,CAAC;AAFuB,KAAX,CAA7B;AAIA,SAAK,MAAL,GAAc,KAAK,OAAL,CAAa,MAA3B;AACA,IAAA,QAAQ,CAAC,IAAD,EAAO,QAAP,CAAR;AACA,SAAK,IAAL,GAAY,OAAO,CAAC,IAApB;AACA;;AAED,SAAO,WAAP,GAAkB;AACjB,WAAO,MAAM,CAAC,MAAP,CAAc,aAAa,CAAC,WAAd,EAAd,EAA2C;AACjD,MAAA,IAAI,EAAE,KAD2C;AAEjD,MAAA,MAAM,EAAE;AAFyC,KAA3C,CAAP;AAIA;AAED;;;;;;;AAOG;;;AACG,EAAA,IAAI,CAAC,SAAD,EAA4B;;AACrC,MAAA,MAAM,CAAC,SAAS,CAAC,SAAX,EAAsB,4BAAtB,CAAN,C,CACA;;AACA,UAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AAC7B,aAAK,KAAL;AACA;;AACD,YAAM,OAAO,GAAG,MAAM,SAAS,CAAC,gBAAV,EAAtB;;AACA,UAAI,QAAQ,CAAC,SAAD,CAAZ,EAAyB;AACxB,aAAK,OAAL,GAAe,OAAO,CAAC,SAAD,CAAtB;AACA,OAFD,MAEO;AACN,aAAK,OAAL,GAAe,OAAO,CAAC,IAAR,CAAc,MAAD,IAAW;AACtC,iBAAO,MAAM,CAAC,KAAP,KAAiB,SAAjB,IAA8B,MAAM,CAAC,QAAP,KAAoB,SAAzD;AACA,SAFc,CAAf,CADM,CAIN;;AACA,YAAI,CAAC,KAAK,OAAN,IAAiB,OAAO,CAAC,MAAR,GAAiB,CAAtC,EAAyC;AACxC,eAAK,OAAL,GAAe,OAAO,CAAC,CAAD,CAAtB;AACA;;AACD,QAAA,MAAM,CAAC,SAAS,CAAC,KAAK,OAAN,CAAV,EAA0B,sBAAsB,SAAS,EAAzD,CAAN;AACA,O,CACD;;;AACA,YAAM,WAAW,GAAG;AACnB,QAAA,KAAK,EAAE;AACN,UAAA,gBAAgB,EAAE,KADZ;AAEN,UAAA,UAAU,EAAE,KAAK,OAAL,CAAa,UAFnB;AAGN,UAAA,gBAAgB,EAAE,KAHZ;AAIN,UAAA,mBAAmB,EAAE;AAJf;AADY,OAApB;;AAQA,UAAI,KAAK,OAAT,EAAkB;AACjB;AACA,QAAA,WAAW,CAAC,KAAZ,CAAkB,QAAlB,GAA6B,KAAK,OAAL,CAAa,QAA1C;AACA;;AACD,YAAM,MAAM,GAAG,MAAM,SAAS,CAAC,YAAV,CAAuB,YAAvB,CAAoC,WAApC,CAArB,C,CACA;;AACA,UAAI,CAAC,KAAK,OAAV,EAAmB;AAClB,aAAK,OAAL,GAAe,MAAf,CADkB,CAElB;;AACA,cAAM,eAAe,GAAG,KAAK,OAAL,CAAa,uBAAb,CAAqC,MAArC,CAAxB,CAHkB,CAIlB;;AACA,QAAA,OAAO,CAAC,eAAD,EAAkB,KAAK,MAAvB,CAAP;AACA,aAAK,YAAL,GAAoB,eAApB;AACA;;AACD,aAAO,IAAP;AACA,K;AAAA;AAED;;AAEG;;;AACH,EAAA,KAAK,GAAA;AACJ,QAAI,KAAK,OAAL,IAAgB,KAAK,YAAzB,EAAuC;AACtC,WAAK,OAAL,CAAa,cAAb,GAA8B,OAA9B,CAAuC,KAAD,IAAU;AAC/C,QAAA,KAAK,CAAC,IAAN;AACA,OAFD;;AAGA,WAAK,OAAL,GAAe,SAAf,CAJsC,CAKtC;;AACA,WAAK,YAAL,CAAkB,UAAlB;;AACA,WAAK,YAAL,GAAoB,SAApB;AACA;;AACD,SAAK,OAAL,GAAe,SAAf;AACA,WAAO,IAAP;AACA;AAED;;;;;;;;AAQG;;;AACH,SAAa,gBAAb,GAA6B;;AAC5B,YAAM,UAAU,GAAG,MAAM,SAAS,CAAC,YAAV,CAAuB,gBAAvB,EAAzB;AACA,aAAO,UAAU,CAAC,MAAX,CAAkB,MAAM,IAAG;AACjC,eAAO,MAAM,CAAC,IAAP,KAAgB,YAAvB;AACA,OAFM,CAAP;AAGA,K;AAAA;AAED;;;AAGG;;;AACH,MAAI,KAAJ,GAAS;AACR,WAAO,KAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,MAA7B,GAAsC,SAAtC,GAAkD,SAAzD;AACA;AAED;;;;;;;AAOG;;;AACH,MAAI,QAAJ,GAAY;AACX,QAAI,KAAK,OAAT,EAAkB;AACjB,aAAO,KAAK,OAAL,CAAa,QAApB;AACA,KAFD,MAEO;AACN,aAAO,SAAP;AACA;AACD;AAED;;;;AAIG;;;AACH,MAAI,OAAJ,GAAW;AACV,QAAI,KAAK,OAAT,EAAkB;AACjB,aAAO,KAAK,OAAL,CAAa,OAApB;AACA,KAFD,MAEO;AACN,aAAO,SAAP;AACA;AACD;AAED;;;;AAIG;;;AACH,MAAI,KAAJ,GAAS;AACR,QAAI,KAAK,OAAT,EAAkB;AACjB,aAAO,KAAK,OAAL,CAAa,KAApB;AACA,KAFD,MAEO;AACN,aAAO,SAAP;AACA;AACD;AAED;;;;;;;;;AASG;;;AACH,MAAI,IAAJ,GAAQ;AACP,WAAO,KAAK,OAAL,CAAa,IAApB;AACA;;AACD,MAAI,IAAJ,CAAS,IAAT,EAAa;AACZ,SAAK,OAAL,CAAa,IAAb,GAAoB,IAApB;AACA;;AAED,EAAA,OAAO,GAAA;AACN,UAAM,OAAN;AACA,SAAK,KAAL;;AACA,SAAK,OAAL,CAAa,OAAb;;AACA,SAAK,MAAL,CAAY,OAAZ;AACA,WAAO,IAAP;AACA;AAED;;AAEG;;;AACH,aAAW,SAAX,GAAoB;AACnB,WAAO,SAAS,CAAC,SAAS,CAAC,YAAX,CAAT,IACN,SAAS,CAAC,SAAS,CAAC,YAAV,CAAuB,YAAxB,CADV;AAEA;;AAjO4D","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\nexport class UserMedia extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n        this.name = \"UserMedia\";\n        const options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n        this._volume = this.output = new Volume({\n            context: this.context,\n            volume: options.volume,\n        });\n        this.volume = this._volume.volume;\n        readOnly(this, \"volume\");\n        this.mute = options.mute;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            volume: 0\n        });\n    }\n    /**\n     * Open the media stream. If a string is passed in, it is assumed\n     * to be the label or id of the stream, if a number is passed in,\n     * it is the input number of the stream.\n     * @param  labelOrId The label or id of the audio input media device.\n     *                   With no argument, the default stream is opened.\n     * @return The promise is resolved when the stream is open.\n     */\n    open(labelOrId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(UserMedia.supported, \"UserMedia is not supported\");\n            // close the previous stream\n            if (this.state === \"started\") {\n                this.close();\n            }\n            const devices = yield UserMedia.enumerateDevices();\n            if (isNumber(labelOrId)) {\n                this._device = devices[labelOrId];\n            }\n            else {\n                this._device = devices.find((device) => {\n                    return device.label === labelOrId || device.deviceId === labelOrId;\n                });\n                // didn't find a matching device\n                if (!this._device && devices.length > 0) {\n                    this._device = devices[0];\n                }\n                assert(isDefined(this._device), `No matching device ${labelOrId}`);\n            }\n            // do getUserMedia\n            const constraints = {\n                audio: {\n                    echoCancellation: false,\n                    sampleRate: this.context.sampleRate,\n                    noiseSuppression: false,\n                    mozNoiseSuppression: false,\n                }\n            };\n            if (this._device) {\n                // @ts-ignore\n                constraints.audio.deviceId = this._device.deviceId;\n            }\n            const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n            // start a new source only if the previous one is closed\n            if (!this._stream) {\n                this._stream = stream;\n                // Wrap a MediaStreamSourceNode around the live input stream.\n                const mediaStreamNode = this.context.createMediaStreamSource(stream);\n                // Connect the MediaStreamSourceNode to a gate gain node\n                connect(mediaStreamNode, this.output);\n                this._mediaStream = mediaStreamNode;\n            }\n            return this;\n        });\n    }\n    /**\n     * Close the media stream\n     */\n    close() {\n        if (this._stream && this._mediaStream) {\n            this._stream.getAudioTracks().forEach((track) => {\n                track.stop();\n            });\n            this._stream = undefined;\n            // remove the old media stream\n            this._mediaStream.disconnect();\n            this._mediaStream = undefined;\n        }\n        this._device = undefined;\n        return this;\n    }\n    /**\n     * Returns a promise which resolves with the list of audio input devices available.\n     * @return The promise that is resolved with the devices\n     * @example\n     * Tone.UserMedia.enumerateDevices().then((devices) => {\n     * \t// print the device labels\n     * \tconsole.log(devices.map(device => device.label));\n     * });\n     */\n    static enumerateDevices() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const allDevices = yield navigator.mediaDevices.enumerateDevices();\n            return allDevices.filter(device => {\n                return device.kind === \"audioinput\";\n            });\n        });\n    }\n    /**\n     * Returns the playback state of the source, \"started\" when the microphone is open\n     * and \"stopped\" when the mic is closed.\n     */\n    get state() {\n        return this._stream && this._stream.active ? \"started\" : \"stopped\";\n    }\n    /**\n     * Returns an identifier for the represented device that is\n     * persisted across sessions. It is un-guessable by other applications and\n     * unique to the origin of the calling application. It is reset when the\n     * user clears cookies (for Private Browsing, a different identifier is\n     * used that is not persisted across sessions). Returns undefined when the\n     * device is not open.\n     */\n    get deviceId() {\n        if (this._device) {\n            return this._device.deviceId;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Returns a group identifier. Two devices have the\n     * same group identifier if they belong to the same physical device.\n     * Returns null  when the device is not open.\n     */\n    get groupId() {\n        if (this._device) {\n            return this._device.groupId;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Returns a label describing this device (for example \"Built-in Microphone\").\n     * Returns undefined when the device is not open or label is not available\n     * because of permissions.\n     */\n    get label() {\n        if (this._device) {\n            return this._device.label;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const mic = new Tone.UserMedia();\n     * mic.open().then(() => {\n     * \t// promise resolves when input is available\n     * });\n     * // mute the output\n     * mic.mute = true;\n     */\n    get mute() {\n        return this._volume.mute;\n    }\n    set mute(mute) {\n        this._volume.mute = mute;\n    }\n    dispose() {\n        super.dispose();\n        this.close();\n        this._volume.dispose();\n        this.volume.dispose();\n        return this;\n    }\n    /**\n     * If getUserMedia is supported by the browser.\n     */\n    static get supported() {\n        return isDefined(navigator.mediaDevices) &&\n            isDefined(navigator.mediaDevices.getUserMedia);\n    }\n}\n//# sourceMappingURL=UserMedia.js.map"]},"metadata":{},"sourceType":"module"}