{"ast":null,"code":"import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Monophonic } from \"../instrument/Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { FrequencyEnvelope } from \"../component/envelope/FrequencyEnvelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\n/**\n * MonoSynth is composed of one `oscillator`, one `filter`, and two `envelopes`.\n * The amplitude of the Oscillator and the cutoff frequency of the\n * Filter are controlled by Envelopes.\n * <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n * @example\n * const synth = new Tone.MonoSynth({\n * \toscillator: {\n * \t\ttype: \"square\"\n * \t},\n * \tenvelope: {\n * \t\tattack: 0.1\n * \t}\n * }).toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\n\nexport class MonoSynth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(MonoSynth.getDefaults(), arguments));\n    this.name = \"MonoSynth\";\n    const options = optionsFromArguments(MonoSynth.getDefaults(), arguments);\n    this.oscillator = new OmniOscillator(Object.assign(options.oscillator, {\n      context: this.context,\n      detune: options.detune,\n      onstop: () => this.onsilence(this)\n    }));\n    this.frequency = this.oscillator.frequency;\n    this.detune = this.oscillator.detune;\n    this.filter = new Filter(Object.assign(options.filter, {\n      context: this.context\n    }));\n    this.filterEnvelope = new FrequencyEnvelope(Object.assign(options.filterEnvelope, {\n      context: this.context\n    }));\n    this.envelope = new AmplitudeEnvelope(Object.assign(options.envelope, {\n      context: this.context\n    })); // connect the oscillators to the output\n\n    this.oscillator.chain(this.filter, this.envelope, this.output); // connect the filter envelope\n\n    this.filterEnvelope.connect(this.filter.frequency);\n    readOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"filter\", \"filterEnvelope\", \"envelope\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Monophonic.getDefaults(), {\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.005,\n        decay: 0.1,\n        release: 1,\n        sustain: 0.9\n      }),\n      filter: Object.assign(omitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        Q: 1,\n        rolloff: -12,\n        type: \"lowpass\"\n      }),\n      filterEnvelope: Object.assign(omitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.6,\n        baseFrequency: 200,\n        decay: 0.2,\n        exponent: 2,\n        octaves: 3,\n        release: 2,\n        sustain: 0.5\n      }),\n      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())), {\n        type: \"sawtooth\"\n      })\n    });\n  }\n  /**\n   * start the attack portion of the envelope\n   * @param time the time the attack should start\n   * @param velocity the velocity of the note (0-1)\n   */\n\n\n  _triggerEnvelopeAttack(time, velocity = 1) {\n    this.envelope.triggerAttack(time, velocity);\n    this.filterEnvelope.triggerAttack(time);\n    this.oscillator.start(time);\n\n    if (this.envelope.sustain === 0) {\n      const computedAttack = this.toSeconds(this.envelope.attack);\n      const computedDecay = this.toSeconds(this.envelope.decay);\n      this.oscillator.stop(time + computedAttack + computedDecay);\n    }\n  }\n  /**\n   * start the release portion of the envelope\n   * @param time the time the release should start\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    this.envelope.triggerRelease(time);\n    this.filterEnvelope.triggerRelease(time);\n    this.oscillator.stop(time + this.toSeconds(this.envelope.release));\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.envelope.getValueAtTime(time);\n  }\n\n  dispose() {\n    super.dispose();\n    this.oscillator.dispose();\n    this.envelope.dispose();\n    this.filterEnvelope.dispose();\n    this.filter.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/instrument/MonoSynth.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Monophonic } from \"../instrument/Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { FrequencyEnvelope } from \"../component/envelope/FrequencyEnvelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\n/**\n * MonoSynth is composed of one `oscillator`, one `filter`, and two `envelopes`.\n * The amplitude of the Oscillator and the cutoff frequency of the\n * Filter are controlled by Envelopes.\n * <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n * @example\n * const synth = new Tone.MonoSynth({\n * \toscillator: {\n * \t\ttype: \"square\"\n * \t},\n * \tenvelope: {\n * \t\tattack: 0.1\n * \t}\n * }).toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class MonoSynth extends Monophonic {\n    constructor() {\n        super(optionsFromArguments(MonoSynth.getDefaults(), arguments));\n        this.name = \"MonoSynth\";\n        const options = optionsFromArguments(MonoSynth.getDefaults(), arguments);\n        this.oscillator = new OmniOscillator(Object.assign(options.oscillator, {\n            context: this.context,\n            detune: options.detune,\n            onstop: () => this.onsilence(this),\n        }));\n        this.frequency = this.oscillator.frequency;\n        this.detune = this.oscillator.detune;\n        this.filter = new Filter(Object.assign(options.filter, { context: this.context }));\n        this.filterEnvelope = new FrequencyEnvelope(Object.assign(options.filterEnvelope, { context: this.context }));\n        this.envelope = new AmplitudeEnvelope(Object.assign(options.envelope, { context: this.context }));\n        // connect the oscillators to the output\n        this.oscillator.chain(this.filter, this.envelope, this.output);\n        // connect the filter envelope\n        this.filterEnvelope.connect(this.filter.frequency);\n        readOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"filter\", \"filterEnvelope\", \"envelope\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Monophonic.getDefaults(), {\n            envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n                attack: 0.005,\n                decay: 0.1,\n                release: 1,\n                sustain: 0.9,\n            }),\n            filter: Object.assign(omitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n                Q: 1,\n                rolloff: -12,\n                type: \"lowpass\",\n            }),\n            filterEnvelope: Object.assign(omitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n                attack: 0.6,\n                baseFrequency: 200,\n                decay: 0.2,\n                exponent: 2,\n                octaves: 3,\n                release: 2,\n                sustain: 0.5,\n            }),\n            oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())), {\n                type: \"sawtooth\",\n            }),\n        });\n    }\n    /**\n     * start the attack portion of the envelope\n     * @param time the time the attack should start\n     * @param velocity the velocity of the note (0-1)\n     */\n    _triggerEnvelopeAttack(time, velocity = 1) {\n        this.envelope.triggerAttack(time, velocity);\n        this.filterEnvelope.triggerAttack(time);\n        this.oscillator.start(time);\n        if (this.envelope.sustain === 0) {\n            const computedAttack = this.toSeconds(this.envelope.attack);\n            const computedDecay = this.toSeconds(this.envelope.decay);\n            this.oscillator.stop(time + computedAttack + computedDecay);\n        }\n    }\n    /**\n     * start the release portion of the envelope\n     * @param time the time the release should start\n     */\n    _triggerEnvelopeRelease(time) {\n        this.envelope.triggerRelease(time);\n        this.filterEnvelope.triggerRelease(time);\n        this.oscillator.stop(time + this.toSeconds(this.envelope.release));\n    }\n    getLevelAtTime(time) {\n        time = this.toSeconds(time);\n        return this.envelope.getValueAtTime(time);\n    }\n    dispose() {\n        super.dispose();\n        this.oscillator.dispose();\n        this.envelope.dispose();\n        this.filterEnvelope.dispose();\n        this.filter.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=MonoSynth.js.map"]},"metadata":{},"sourceType":"module"}