{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\n\nexport class Context extends BaseContext {\n  constructor() {\n    super();\n    this.name = \"Context\";\n    /**\n     * An object containing all of the constants AudioBufferSourceNodes\n     */\n\n    this._constants = new Map();\n    /**\n     * All of the setTimeout events.\n     */\n\n    this._timeouts = new Timeline();\n    /**\n     * The timeout id counter\n     */\n\n    this._timeoutIds = 0;\n    /**\n     * Private indicator if the context has been initialized\n     */\n\n    this._initialized = false;\n    /**\n     * Indicates if the context is an OfflineAudioContext or an AudioContext\n     */\n\n    this.isOffline = false; //--------------------------------------------\n    // AUDIO WORKLET\n    //--------------------------------------------\n\n    /**\n     * Maps a module name to promise of the addModule method\n     */\n\n    this._workletModules = new Map();\n    const options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n    if (options.context) {\n      this._context = options.context;\n    } else {\n      this._context = createAudioContext({\n        latencyHint: options.latencyHint\n      });\n    }\n\n    this._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n    this.on(\"tick\", this._timeoutLoop.bind(this)); // fwd events from the context\n\n    this._context.onstatechange = () => {\n      this.emit(\"statechange\", this.state);\n    };\n\n    this._setLatencyHint(options.latencyHint);\n\n    this.lookAhead = options.lookAhead;\n  }\n\n  static getDefaults() {\n    return {\n      clockSource: \"worker\",\n      latencyHint: \"interactive\",\n      lookAhead: 0.1,\n      updateInterval: 0.05\n    };\n  }\n  /**\n   * Finish setting up the context. **You usually do not need to do this manually.**\n   */\n\n\n  initialize() {\n    if (!this._initialized) {\n      // add any additional modules\n      initializeContext(this);\n      this._initialized = true;\n    }\n\n    return this;\n  } //---------------------------\n  // BASE AUDIO CONTEXT METHODS\n  //---------------------------\n\n\n  createAnalyser() {\n    return this._context.createAnalyser();\n  }\n\n  createOscillator() {\n    return this._context.createOscillator();\n  }\n\n  createBufferSource() {\n    return this._context.createBufferSource();\n  }\n\n  createBiquadFilter() {\n    return this._context.createBiquadFilter();\n  }\n\n  createBuffer(numberOfChannels, length, sampleRate) {\n    return this._context.createBuffer(numberOfChannels, length, sampleRate);\n  }\n\n  createChannelMerger(numberOfInputs) {\n    return this._context.createChannelMerger(numberOfInputs);\n  }\n\n  createChannelSplitter(numberOfOutputs) {\n    return this._context.createChannelSplitter(numberOfOutputs);\n  }\n\n  createConstantSource() {\n    return this._context.createConstantSource();\n  }\n\n  createConvolver() {\n    return this._context.createConvolver();\n  }\n\n  createDelay(maxDelayTime) {\n    return this._context.createDelay(maxDelayTime);\n  }\n\n  createDynamicsCompressor() {\n    return this._context.createDynamicsCompressor();\n  }\n\n  createGain() {\n    return this._context.createGain();\n  }\n\n  createIIRFilter(feedForward, feedback) {\n    // @ts-ignore\n    return this._context.createIIRFilter(feedForward, feedback);\n  }\n\n  createPanner() {\n    return this._context.createPanner();\n  }\n\n  createPeriodicWave(real, imag, constraints) {\n    return this._context.createPeriodicWave(real, imag, constraints);\n  }\n\n  createStereoPanner() {\n    return this._context.createStereoPanner();\n  }\n\n  createWaveShaper() {\n    return this._context.createWaveShaper();\n  }\n\n  createMediaStreamSource(stream) {\n    assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n    const context = this._context;\n    return context.createMediaStreamSource(stream);\n  }\n\n  createMediaStreamDestination() {\n    assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n    const context = this._context;\n    return context.createMediaStreamDestination();\n  }\n\n  decodeAudioData(audioData) {\n    return this._context.decodeAudioData(audioData);\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n\n\n  get currentTime() {\n    return this._context.currentTime;\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n\n\n  get state() {\n    return this._context.state;\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n\n\n  get sampleRate() {\n    return this._context.sampleRate;\n  }\n  /**\n   * The listener\n   */\n\n\n  get listener() {\n    this.initialize();\n    return this._listener;\n  }\n\n  set listener(l) {\n    assert(!this._initialized, \"The listener cannot be set after initialization.\");\n    this._listener = l;\n  }\n  /**\n   * There is only one Transport per Context. It is created on initialization.\n   */\n\n\n  get transport() {\n    this.initialize();\n    return this._transport;\n  }\n\n  set transport(t) {\n    assert(!this._initialized, \"The transport cannot be set after initialization.\");\n    this._transport = t;\n  }\n  /**\n   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n   */\n\n\n  get draw() {\n    this.initialize();\n    return this._draw;\n  }\n\n  set draw(d) {\n    assert(!this._initialized, \"Draw cannot be set after initialization.\");\n    this._draw = d;\n  }\n  /**\n   * A reference to the Context's destination node.\n   */\n\n\n  get destination() {\n    this.initialize();\n    return this._destination;\n  }\n\n  set destination(d) {\n    assert(!this._initialized, \"The destination cannot be set after initialization.\");\n    this._destination = d;\n  }\n  /**\n   * Create an audio worklet node from a name and options. The module\n   * must first be loaded using [[addAudioWorkletModule]].\n   */\n\n\n  createAudioWorkletNode(name, options) {\n    return createAudioWorkletNode(this.rawContext, name, options);\n  }\n  /**\n   * Add an AudioWorkletProcessor module\n   * @param url The url of the module\n   * @param name The name of the module\n   */\n\n\n  addAudioWorkletModule(url, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n\n      if (!this._workletModules.has(name)) {\n        this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n      }\n\n      yield this._workletModules.get(name);\n    });\n  }\n  /**\n   * Returns a promise which resolves when all of the worklets have been loaded on this context\n   */\n\n\n  workletsAreReady() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [];\n\n      this._workletModules.forEach(promise => promises.push(promise));\n\n      yield Promise.all(promises);\n    });\n  } //---------------------------\n  // TICKER\n  //---------------------------\n\n  /**\n   * How often the interval callback is invoked.\n   * This number corresponds to how responsive the scheduling\n   * can be. context.updateInterval + context.lookAhead gives you the\n   * total latency between scheduling an event and hearing it.\n   */\n\n\n  get updateInterval() {\n    return this._ticker.updateInterval;\n  }\n\n  set updateInterval(interval) {\n    this._ticker.updateInterval = interval;\n  }\n  /**\n   * What the source of the clock is, either \"worker\" (default),\n   * \"timeout\", or \"offline\" (none).\n   */\n\n\n  get clockSource() {\n    return this._ticker.type;\n  }\n\n  set clockSource(type) {\n    this._ticker.type = type;\n  }\n  /**\n   * The type of playback, which affects tradeoffs between audio\n   * output latency and responsiveness.\n   * In addition to setting the value in seconds, the latencyHint also\n   * accepts the strings \"interactive\" (prioritizes low latency),\n   * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n   * latency and performance).\n   * @example\n   * // prioritize sustained playback\n   * const context = new Tone.Context({ latencyHint: \"playback\" });\n   * // set this context as the global Context\n   * Tone.setContext(context);\n   * // the global context is gettable with Tone.getContext()\n   * console.log(Tone.getContext().latencyHint);\n   */\n\n\n  get latencyHint() {\n    return this._latencyHint;\n  }\n  /**\n   * Update the lookAhead and updateInterval based on the latencyHint\n   */\n\n\n  _setLatencyHint(hint) {\n    let lookAheadValue = 0;\n    this._latencyHint = hint;\n\n    if (isString(hint)) {\n      switch (hint) {\n        case \"interactive\":\n          lookAheadValue = 0.1;\n          break;\n\n        case \"playback\":\n          lookAheadValue = 0.5;\n          break;\n\n        case \"balanced\":\n          lookAheadValue = 0.25;\n          break;\n      }\n    }\n\n    this.lookAhead = lookAheadValue;\n    this.updateInterval = lookAheadValue / 2;\n  }\n  /**\n   * The unwrapped AudioContext or OfflineAudioContext\n   */\n\n\n  get rawContext() {\n    return this._context;\n  }\n  /**\n   * The current audio context time plus a short [[lookAhead]].\n   */\n\n\n  now() {\n    return this._context.currentTime + this.lookAhead;\n  }\n  /**\n   * The current audio context time without the [[lookAhead]].\n   * In most cases it is better to use [[now]] instead of [[immediate]] since\n   * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n   * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n   * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n   */\n\n\n  immediate() {\n    return this._context.currentTime;\n  }\n  /**\n   * Starts the audio context from a suspended state. This is required\n   * to initially start the AudioContext. See [[Tone.start]]\n   */\n\n\n  resume() {\n    if (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n      return this._context.resume();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  /**\n   * Close the context. Once closed, the context can no longer be used and\n   * any AudioNodes created from the context will be silent.\n   */\n\n\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isAudioContext(this._context)) {\n        yield this._context.close();\n      }\n\n      if (this._initialized) {\n        closeContext(this);\n      }\n    });\n  }\n  /**\n   * **Internal** Generate a looped buffer at some constant value.\n   */\n\n\n  getConstant(val) {\n    if (this._constants.has(val)) {\n      return this._constants.get(val);\n    } else {\n      const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\n      const arr = buffer.getChannelData(0);\n\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = val;\n      }\n\n      const constant = this._context.createBufferSource();\n\n      constant.channelCount = 1;\n      constant.channelCountMode = \"explicit\";\n      constant.buffer = buffer;\n      constant.loop = true;\n      constant.start(0);\n\n      this._constants.set(val, constant);\n\n      return constant;\n    }\n  }\n  /**\n   * Clean up. Also closes the audio context.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._ticker.dispose();\n\n    this._timeouts.dispose();\n\n    Object.keys(this._constants).map(val => this._constants[val].disconnect());\n    return this;\n  } //---------------------------\n  // TIMEOUTS\n  //---------------------------\n\n  /**\n   * The private loop which keeps track of the context scheduled timeouts\n   * Is invoked from the clock source\n   */\n\n\n  _timeoutLoop() {\n    const now = this.now();\n\n    let firstEvent = this._timeouts.peek();\n\n    while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n      // invoke the callback\n      firstEvent.callback(); // shift the first event off\n\n      this._timeouts.shift(); // get the next one\n\n\n      firstEvent = this._timeouts.peek();\n    }\n  }\n  /**\n   * A setTimeout which is guaranteed by the clock source.\n   * Also runs in the offline context.\n   * @param  fn       The callback to invoke\n   * @param  timeout  The timeout in seconds\n   * @returns ID to use when invoking Context.clearTimeout\n   */\n\n\n  setTimeout(fn, timeout) {\n    this._timeoutIds++;\n    const now = this.now();\n\n    this._timeouts.add({\n      callback: fn,\n      id: this._timeoutIds,\n      time: now + timeout\n    });\n\n    return this._timeoutIds;\n  }\n  /**\n   * Clears a previously scheduled timeout with Tone.context.setTimeout\n   * @param  id  The ID returned from setTimeout\n   */\n\n\n  clearTimeout(id) {\n    this._timeouts.forEach(event => {\n      if (event.id === id) {\n        this._timeouts.remove(event);\n      }\n    });\n\n    return this;\n  }\n  /**\n   * Clear the function scheduled by [[setInterval]]\n   */\n\n\n  clearInterval(id) {\n    return this.clearTimeout(id);\n  }\n  /**\n   * Adds a repeating event to the context's callback clock\n   */\n\n\n  setInterval(fn, interval) {\n    const id = ++this._timeoutIds;\n\n    const intervalFn = () => {\n      const now = this.now();\n\n      this._timeouts.add({\n        callback: () => {\n          // invoke the callback\n          fn(); // invoke the event to repeat it\n\n          intervalFn();\n        },\n        id,\n        time: now + interval\n      });\n    }; // kick it off\n\n\n    intervalFn();\n    return id;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/core/context/Context.ts"],"names":[],"mappings":";AAAA,SAAS,MAAT,QAA0C,iBAA1C;AAEA,SAAS,cAAT,QAA+B,2BAA/B;AACA,SAAS,oBAAT,QAAqC,kBAArC;AAEA,SAAS,QAAT,QAAyB,kBAAzB;AACA,SAAS,SAAT,EAAoB,QAApB,QAAoC,mBAApC;AACA,SAA0B,kBAA1B,EAA8C,sBAA9C,QAA4E,gBAA5E;AACA,SAAS,YAAT,EAAuB,iBAAvB,QAAgD,yBAAhD;AACA,SAAS,WAAT,QAAgD,eAAhD;AACA,SAAS,MAAT,QAAuB,eAAvB;AA6BA;;;AAGG;;AACH,OAAM,MAAO,OAAP,SAAuB,WAAvB,CAAkC;AAyEvC,EAAA,WAAA,GAAA;AACC;AAxEQ,SAAA,IAAA,GAAe,SAAf;AAwBT;;AAEG;;AACK,SAAA,UAAA,GAAa,IAAI,GAAJ,EAAb;AAER;;AAEG;;AACK,SAAA,SAAA,GAA2C,IAAI,QAAJ,EAA3C;AAER;;AAEG;;AACK,SAAA,WAAA,GAAc,CAAd;AAsBR;;AAEG;;AACK,SAAA,YAAA,GAAe,KAAf;AAER;;AAEG;;AACM,SAAA,SAAA,GAAqB,KAArB,CAIT,CA0LA;AACA;AACA;;AAEA;;AAEG;;AACK,SAAA,eAAA,GAA8C,IAAI,GAAJ,EAA9C;AA/LP,UAAM,OAAO,GAAG,oBAAoB,CAAC,OAAO,CAAC,WAAR,EAAD,EAAwB,SAAxB,EAAmC,CAAC,SAAD,CAAnC,CAApC;;AAEA,QAAI,OAAO,CAAC,OAAZ,EAAqB;AACpB,WAAK,QAAL,GAAgB,OAAO,CAAC,OAAxB;AACA,KAFD,MAEO;AACN,WAAK,QAAL,GAAgB,kBAAkB,CAAC;AAClC,QAAA,WAAW,EAAE,OAAO,CAAC;AADa,OAAD,CAAlC;AAGA;;AAED,SAAK,OAAL,GAAe,IAAI,MAAJ,CAAW,KAAK,IAAL,CAAU,IAAV,CAAe,IAAf,EAAqB,MAArB,CAAX,EAAyC,OAAO,CAAC,WAAjD,EAA8D,OAAO,CAAC,cAAtE,CAAf;AACA,SAAK,EAAL,CAAQ,MAAR,EAAgB,KAAK,YAAL,CAAkB,IAAlB,CAAuB,IAAvB,CAAhB,EAbD,CAeC;;AACA,SAAK,QAAL,CAAc,aAAd,GAA8B,MAAK;AAClC,WAAK,IAAL,CAAU,aAAV,EAAyB,KAAK,KAA9B;AACA,KAFD;;AAIA,SAAK,eAAL,CAAqB,OAAO,CAAC,WAA7B;;AACA,SAAK,SAAL,GAAiB,OAAO,CAAC,SAAzB;AACA;;AAED,SAAO,WAAP,GAAkB;AACjB,WAAO;AACN,MAAA,WAAW,EAAE,QADP;AAEN,MAAA,WAAW,EAAE,aAFP;AAGN,MAAA,SAAS,EAAE,GAHL;AAIN,MAAA,cAAc,EAAE;AAJV,KAAP;AAMA;AAED;;AAEG;;;AACK,EAAA,UAAU,GAAA;AACjB,QAAI,CAAC,KAAK,YAAV,EAAwB;AACvB;AACA,MAAA,iBAAiB,CAAC,IAAD,CAAjB;AACA,WAAK,YAAL,GAAoB,IAApB;AACA;;AACD,WAAO,IAAP;AACA,GApHsC,CAsHvC;AACA;AACA;;;AAEA,EAAA,cAAc,GAAA;AACb,WAAO,KAAK,QAAL,CAAc,cAAd,EAAP;AACA;;AACD,EAAA,gBAAgB,GAAA;AACf,WAAO,KAAK,QAAL,CAAc,gBAAd,EAAP;AACA;;AACD,EAAA,kBAAkB,GAAA;AACjB,WAAO,KAAK,QAAL,CAAc,kBAAd,EAAP;AACA;;AACD,EAAA,kBAAkB,GAAA;AACjB,WAAO,KAAK,QAAL,CAAc,kBAAd,EAAP;AACA;;AACD,EAAA,YAAY,CAAC,gBAAD,EAA2B,MAA3B,EAA2C,UAA3C,EAA6D;AACxE,WAAO,KAAK,QAAL,CAAc,YAAd,CAA2B,gBAA3B,EAA6C,MAA7C,EAAqD,UAArD,CAAP;AACA;;AACD,EAAA,mBAAmB,CAAC,cAAD,EAAoC;AACtD,WAAO,KAAK,QAAL,CAAc,mBAAd,CAAkC,cAAlC,CAAP;AACA;;AACD,EAAA,qBAAqB,CAAC,eAAD,EAAqC;AACzD,WAAO,KAAK,QAAL,CAAc,qBAAd,CAAoC,eAApC,CAAP;AACA;;AACD,EAAA,oBAAoB,GAAA;AACnB,WAAO,KAAK,QAAL,CAAc,oBAAd,EAAP;AACA;;AACD,EAAA,eAAe,GAAA;AACd,WAAO,KAAK,QAAL,CAAc,eAAd,EAAP;AACA;;AACD,EAAA,WAAW,CAAC,YAAD,EAAkC;AAC5C,WAAO,KAAK,QAAL,CAAc,WAAd,CAA0B,YAA1B,CAAP;AACA;;AACD,EAAA,wBAAwB,GAAA;AACvB,WAAO,KAAK,QAAL,CAAc,wBAAd,EAAP;AACA;;AACD,EAAA,UAAU,GAAA;AACT,WAAO,KAAK,QAAL,CAAc,UAAd,EAAP;AACA;;AACD,EAAA,eAAe,CAAC,WAAD,EAAuC,QAAvC,EAAwE;AACtF;AACA,WAAO,KAAK,QAAL,CAAc,eAAd,CAA8B,WAA9B,EAA2C,QAA3C,CAAP;AACA;;AACD,EAAA,YAAY,GAAA;AACX,WAAO,KAAK,QAAL,CAAc,YAAd,EAAP;AACA;;AACD,EAAA,kBAAkB,CACjB,IADiB,EAEjB,IAFiB,EAGjB,WAHiB,EAGgC;AAEjD,WAAO,KAAK,QAAL,CAAc,kBAAd,CAAiC,IAAjC,EAAuC,IAAvC,EAA6C,WAA7C,CAAP;AACA;;AACD,EAAA,kBAAkB,GAAA;AACjB,WAAO,KAAK,QAAL,CAAc,kBAAd,EAAP;AACA;;AACD,EAAA,gBAAgB,GAAA;AACf,WAAO,KAAK,QAAL,CAAc,gBAAd,EAAP;AACA;;AACD,EAAA,uBAAuB,CAAC,MAAD,EAAoB;AAC1C,IAAA,MAAM,CAAC,cAAc,CAAC,KAAK,QAAN,CAAf,EAAgC,sCAAhC,CAAN;AACA,UAAM,OAAO,GAAG,KAAK,QAArB;AACA,WAAO,OAAO,CAAC,uBAAR,CAAgC,MAAhC,CAAP;AACA;;AACD,EAAA,4BAA4B,GAAA;AAC3B,IAAA,MAAM,CAAC,cAAc,CAAC,KAAK,QAAN,CAAf,EAAgC,sCAAhC,CAAN;AACA,UAAM,OAAO,GAAG,KAAK,QAArB;AACA,WAAO,OAAO,CAAC,4BAAR,EAAP;AACA;;AACD,EAAA,eAAe,CAAC,SAAD,EAAuB;AACrC,WAAO,KAAK,QAAL,CAAc,eAAd,CAA8B,SAA9B,CAAP;AACA;AAED;;AAEG;;;AACH,MAAI,WAAJ,GAAe;AACd,WAAO,KAAK,QAAL,CAAc,WAArB;AACA;AACD;;AAEG;;;AACH,MAAI,KAAJ,GAAS;AACR,WAAO,KAAK,QAAL,CAAc,KAArB;AACA;AACD;;AAEG;;;AACH,MAAI,UAAJ,GAAc;AACb,WAAO,KAAK,QAAL,CAAc,UAArB;AACA;AAED;;AAEG;;;AACH,MAAI,QAAJ,GAAY;AACX,SAAK,UAAL;AACA,WAAO,KAAK,SAAZ;AACA;;AACD,MAAI,QAAJ,CAAa,CAAb,EAAc;AACb,IAAA,MAAM,CAAC,CAAC,KAAK,YAAP,EAAqB,kDAArB,CAAN;AACA,SAAK,SAAL,GAAiB,CAAjB;AACA;AAED;;AAEG;;;AACH,MAAI,SAAJ,GAAa;AACZ,SAAK,UAAL;AACA,WAAO,KAAK,UAAZ;AACA;;AACD,MAAI,SAAJ,CAAc,CAAd,EAA0B;AACzB,IAAA,MAAM,CAAC,CAAC,KAAK,YAAP,EAAqB,mDAArB,CAAN;AACA,SAAK,UAAL,GAAkB,CAAlB;AACA;AAED;;AAEG;;;AACH,MAAI,IAAJ,GAAQ;AACP,SAAK,UAAL;AACA,WAAO,KAAK,KAAZ;AACA;;AACD,MAAI,IAAJ,CAAS,CAAT,EAAU;AACT,IAAA,MAAM,CAAC,CAAC,KAAK,YAAP,EAAqB,0CAArB,CAAN;AACA,SAAK,KAAL,GAAa,CAAb;AACA;AAED;;AAEG;;;AACH,MAAI,WAAJ,GAAe;AACd,SAAK,UAAL;AACA,WAAO,KAAK,YAAZ;AACA;;AACD,MAAI,WAAJ,CAAgB,CAAhB,EAA8B;AAC7B,IAAA,MAAM,CAAC,CAAC,KAAK,YAAP,EAAqB,qDAArB,CAAN;AACA,SAAK,YAAL,GAAoB,CAApB;AACA;AAWD;;;AAGG;;;AACH,EAAA,sBAAsB,CACrB,IADqB,EAErB,OAFqB,EAEqB;AAE1C,WAAO,sBAAsB,CAAC,KAAK,UAAN,EAAkB,IAAlB,EAAwB,OAAxB,CAA7B;AACA;AAED;;;;AAIG;;;AACG,EAAA,qBAAqB,CAAC,GAAD,EAAc,IAAd,EAA0B;;AACpD,MAAA,MAAM,CAAC,SAAS,CAAC,KAAK,UAAL,CAAgB,YAAjB,CAAV,EAA0C,6EAA1C,CAAN;;AACA,UAAI,CAAC,KAAK,eAAL,CAAqB,GAArB,CAAyB,IAAzB,CAAL,EAAqC;AACpC,aAAK,eAAL,CAAqB,GAArB,CAAyB,IAAzB,EAA+B,KAAK,UAAL,CAAgB,YAAhB,CAA6B,SAA7B,CAAuC,GAAvC,CAA/B;AACA;;AACD,YAAM,KAAK,eAAL,CAAqB,GAArB,CAAyB,IAAzB,CAAN;AACA,K;AAAA;AAED;;AAEG;;;AACa,EAAA,gBAAgB,GAAA;;AAC/B,YAAM,QAAQ,GAAoB,EAAlC;;AACA,WAAK,eAAL,CAAqB,OAArB,CAA6B,OAAO,IAAI,QAAQ,CAAC,IAAT,CAAc,OAAd,CAAxC;;AACA,YAAM,OAAO,CAAC,GAAR,CAAY,QAAZ,CAAN;AACA,K;AAAA,GA3SsC,CA6SvC;AACA;AACA;;AAEA;;;;;AAKG;;;AACH,MAAI,cAAJ,GAAkB;AACjB,WAAO,KAAK,OAAL,CAAa,cAApB;AACA;;AACD,MAAI,cAAJ,CAAmB,QAAnB,EAAoC;AACnC,SAAK,OAAL,CAAa,cAAb,GAA8B,QAA9B;AACA;AAED;;;AAGG;;;AACH,MAAI,WAAJ,GAAe;AACd,WAAO,KAAK,OAAL,CAAa,IAApB;AACA;;AACD,MAAI,WAAJ,CAAgB,IAAhB,EAAuC;AACtC,SAAK,OAAL,CAAa,IAAb,GAAoB,IAApB;AACA;AAED;;;;;;;;;;;;;;AAcG;;;AACH,MAAI,WAAJ,GAAe;AACd,WAAO,KAAK,YAAZ;AACA;AAED;;AAEG;;;AACK,EAAA,eAAe,CAAC,IAAD,EAAmC;AACzD,QAAI,cAAc,GAAG,CAArB;AACA,SAAK,YAAL,GAAoB,IAApB;;AACA,QAAI,QAAQ,CAAC,IAAD,CAAZ,EAAoB;AACnB,cAAQ,IAAR;AACC,aAAK,aAAL;AACC,UAAA,cAAc,GAAG,GAAjB;AACA;;AACD,aAAK,UAAL;AACC,UAAA,cAAc,GAAG,GAAjB;AACA;;AACD,aAAK,UAAL;AACC,UAAA,cAAc,GAAG,IAAjB;AACA;AATF;AAWA;;AACD,SAAK,SAAL,GAAiB,cAAjB;AACA,SAAK,cAAL,GAAsB,cAAc,GAAG,CAAvC;AACA;AAED;;AAEG;;;AACH,MAAI,UAAJ,GAAc;AACb,WAAO,KAAK,QAAZ;AACA;AAED;;AAEG;;;AACH,EAAA,GAAG,GAAA;AACF,WAAO,KAAK,QAAL,CAAc,WAAd,GAA4B,KAAK,SAAxC;AACA;AAED;;;;;;AAMG;;;AACH,EAAA,SAAS,GAAA;AACR,WAAO,KAAK,QAAL,CAAc,WAArB;AACA;AAED;;;AAGG;;;AACH,EAAA,MAAM,GAAA;AACL,QAAI,KAAK,QAAL,CAAc,KAAd,KAAwB,WAAxB,IAAuC,cAAc,CAAC,KAAK,QAAN,CAAzD,EAA0E;AACzE,aAAO,KAAK,QAAL,CAAc,MAAd,EAAP;AACA,KAFD,MAEO;AACN,aAAO,OAAO,CAAC,OAAR,EAAP;AACA;AACD;AAED;;;AAGG;;;AACG,EAAA,KAAK,GAAA;;AACV,UAAI,cAAc,CAAC,KAAK,QAAN,CAAlB,EAAmC;AAClC,cAAM,KAAK,QAAL,CAAc,KAAd,EAAN;AACA;;AACD,UAAI,KAAK,YAAT,EAAuB;AACtB,QAAA,YAAY,CAAC,IAAD,CAAZ;AACA;AACD,K;AAAA;AAED;;AAEG;;;AACH,EAAA,WAAW,CAAC,GAAD,EAAY;AACtB,QAAI,KAAK,UAAL,CAAgB,GAAhB,CAAoB,GAApB,CAAJ,EAA8B;AAC7B,aAAO,KAAK,UAAL,CAAgB,GAAhB,CAAoB,GAApB,CAAP;AACA,KAFD,MAEO;AACN,YAAM,MAAM,GAAG,KAAK,QAAL,CAAc,YAAd,CAA2B,CAA3B,EAA8B,GAA9B,EAAmC,KAAK,QAAL,CAAc,UAAjD,CAAf;;AACA,YAAM,GAAG,GAAG,MAAM,CAAC,cAAP,CAAsB,CAAtB,CAAZ;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,EAAjC,EAAqC;AACpC,QAAA,GAAG,CAAC,CAAD,CAAH,GAAS,GAAT;AACA;;AACD,YAAM,QAAQ,GAAG,KAAK,QAAL,CAAc,kBAAd,EAAjB;;AACA,MAAA,QAAQ,CAAC,YAAT,GAAwB,CAAxB;AACA,MAAA,QAAQ,CAAC,gBAAT,GAA4B,UAA5B;AACA,MAAA,QAAQ,CAAC,MAAT,GAAkB,MAAlB;AACA,MAAA,QAAQ,CAAC,IAAT,GAAgB,IAAhB;AACA,MAAA,QAAQ,CAAC,KAAT,CAAe,CAAf;;AACA,WAAK,UAAL,CAAgB,GAAhB,CAAoB,GAApB,EAAyB,QAAzB;;AACA,aAAO,QAAP;AACA;AACD;AAED;;AAEG;;;AACH,EAAA,OAAO,GAAA;AACN,UAAM,OAAN;;AACA,SAAK,OAAL,CAAa,OAAb;;AACA,SAAK,SAAL,CAAe,OAAf;;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,KAAK,UAAjB,EAA6B,GAA7B,CAAiC,GAAG,IAAI,KAAK,UAAL,CAAgB,GAAhB,EAAqB,UAArB,EAAxC;AACA,WAAO,IAAP;AACA,GArcsC,CAucvC;AACA;AACA;;AAEA;;;AAGG;;;AACK,EAAA,YAAY,GAAA;AACnB,UAAM,GAAG,GAAG,KAAK,GAAL,EAAZ;;AACA,QAAI,UAAU,GAAG,KAAK,SAAL,CAAe,IAAf,EAAjB;;AACA,WAAO,KAAK,SAAL,CAAe,MAAf,IAAyB,UAAzB,IAAuC,UAAU,CAAC,IAAX,IAAmB,GAAjE,EAAsE;AACrE;AACA,MAAA,UAAU,CAAC,QAAX,GAFqE,CAGrE;;AACA,WAAK,SAAL,CAAe,KAAf,GAJqE,CAKrE;;;AACA,MAAA,UAAU,GAAG,KAAK,SAAL,CAAe,IAAf,EAAb;AACA;AACD;AAED;;;;;;AAMG;;;AACH,EAAA,UAAU,CAAC,EAAD,EAA+B,OAA/B,EAA+C;AACxD,SAAK,WAAL;AACA,UAAM,GAAG,GAAG,KAAK,GAAL,EAAZ;;AACA,SAAK,SAAL,CAAe,GAAf,CAAmB;AAClB,MAAA,QAAQ,EAAE,EADQ;AAElB,MAAA,EAAE,EAAE,KAAK,WAFS;AAGlB,MAAA,IAAI,EAAE,GAAG,GAAG;AAHM,KAAnB;;AAKA,WAAO,KAAK,WAAZ;AACA;AAED;;;AAGG;;;AACH,EAAA,YAAY,CAAC,EAAD,EAAW;AACtB,SAAK,SAAL,CAAe,OAAf,CAAuB,KAAK,IAAG;AAC9B,UAAI,KAAK,CAAC,EAAN,KAAa,EAAjB,EAAqB;AACpB,aAAK,SAAL,CAAe,MAAf,CAAsB,KAAtB;AACA;AACD,KAJD;;AAKA,WAAO,IAAP;AACA;AAED;;AAEG;;;AACH,EAAA,aAAa,CAAC,EAAD,EAAW;AACvB,WAAO,KAAK,YAAL,CAAkB,EAAlB,CAAP;AACA;AAED;;AAEG;;;AACH,EAAA,WAAW,CAAC,EAAD,EAA+B,QAA/B,EAAgD;AAC1D,UAAM,EAAE,GAAG,EAAE,KAAK,WAAlB;;AACA,UAAM,UAAU,GAAG,MAAK;AACvB,YAAM,GAAG,GAAG,KAAK,GAAL,EAAZ;;AACA,WAAK,SAAL,CAAe,GAAf,CAAmB;AAClB,QAAA,QAAQ,EAAE,MAAK;AACd;AACA,UAAA,EAAE,GAFY,CAGd;;AACA,UAAA,UAAU;AACV,SANiB;AAOlB,QAAA,EAPkB;AAQlB,QAAA,IAAI,EAAE,GAAG,GAAG;AARM,OAAnB;AAUA,KAZD,CAF0D,CAe1D;;;AACA,IAAA,UAAU;AACV,WAAO,EAAP;AACA;;AAvhBsC","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends BaseContext {\n    constructor() {\n        super();\n        this.name = \"Context\";\n        /**\n         * An object containing all of the constants AudioBufferSourceNodes\n         */\n        this._constants = new Map();\n        /**\n         * All of the setTimeout events.\n         */\n        this._timeouts = new Timeline();\n        /**\n         * The timeout id counter\n         */\n        this._timeoutIds = 0;\n        /**\n         * Private indicator if the context has been initialized\n         */\n        this._initialized = false;\n        /**\n         * Indicates if the context is an OfflineAudioContext or an AudioContext\n         */\n        this.isOffline = false;\n        //--------------------------------------------\n        // AUDIO WORKLET\n        //--------------------------------------------\n        /**\n         * Maps a module name to promise of the addModule method\n         */\n        this._workletModules = new Map();\n        const options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n        if (options.context) {\n            this._context = options.context;\n        }\n        else {\n            this._context = createAudioContext({\n                latencyHint: options.latencyHint,\n            });\n        }\n        this._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n        this.on(\"tick\", this._timeoutLoop.bind(this));\n        // fwd events from the context\n        this._context.onstatechange = () => {\n            this.emit(\"statechange\", this.state);\n        };\n        this._setLatencyHint(options.latencyHint);\n        this.lookAhead = options.lookAhead;\n    }\n    static getDefaults() {\n        return {\n            clockSource: \"worker\",\n            latencyHint: \"interactive\",\n            lookAhead: 0.1,\n            updateInterval: 0.05,\n        };\n    }\n    /**\n     * Finish setting up the context. **You usually do not need to do this manually.**\n     */\n    initialize() {\n        if (!this._initialized) {\n            // add any additional modules\n            initializeContext(this);\n            this._initialized = true;\n        }\n        return this;\n    }\n    //---------------------------\n    // BASE AUDIO CONTEXT METHODS\n    //---------------------------\n    createAnalyser() {\n        return this._context.createAnalyser();\n    }\n    createOscillator() {\n        return this._context.createOscillator();\n    }\n    createBufferSource() {\n        return this._context.createBufferSource();\n    }\n    createBiquadFilter() {\n        return this._context.createBiquadFilter();\n    }\n    createBuffer(numberOfChannels, length, sampleRate) {\n        return this._context.createBuffer(numberOfChannels, length, sampleRate);\n    }\n    createChannelMerger(numberOfInputs) {\n        return this._context.createChannelMerger(numberOfInputs);\n    }\n    createChannelSplitter(numberOfOutputs) {\n        return this._context.createChannelSplitter(numberOfOutputs);\n    }\n    createConstantSource() {\n        return this._context.createConstantSource();\n    }\n    createConvolver() {\n        return this._context.createConvolver();\n    }\n    createDelay(maxDelayTime) {\n        return this._context.createDelay(maxDelayTime);\n    }\n    createDynamicsCompressor() {\n        return this._context.createDynamicsCompressor();\n    }\n    createGain() {\n        return this._context.createGain();\n    }\n    createIIRFilter(feedForward, feedback) {\n        // @ts-ignore\n        return this._context.createIIRFilter(feedForward, feedback);\n    }\n    createPanner() {\n        return this._context.createPanner();\n    }\n    createPeriodicWave(real, imag, constraints) {\n        return this._context.createPeriodicWave(real, imag, constraints);\n    }\n    createStereoPanner() {\n        return this._context.createStereoPanner();\n    }\n    createWaveShaper() {\n        return this._context.createWaveShaper();\n    }\n    createMediaStreamSource(stream) {\n        assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n        const context = this._context;\n        return context.createMediaStreamSource(stream);\n    }\n    createMediaStreamDestination() {\n        assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n        const context = this._context;\n        return context.createMediaStreamDestination();\n    }\n    decodeAudioData(audioData) {\n        return this._context.decodeAudioData(audioData);\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get currentTime() {\n        return this._context.currentTime;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get state() {\n        return this._context.state;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get sampleRate() {\n        return this._context.sampleRate;\n    }\n    /**\n     * The listener\n     */\n    get listener() {\n        this.initialize();\n        return this._listener;\n    }\n    set listener(l) {\n        assert(!this._initialized, \"The listener cannot be set after initialization.\");\n        this._listener = l;\n    }\n    /**\n     * There is only one Transport per Context. It is created on initialization.\n     */\n    get transport() {\n        this.initialize();\n        return this._transport;\n    }\n    set transport(t) {\n        assert(!this._initialized, \"The transport cannot be set after initialization.\");\n        this._transport = t;\n    }\n    /**\n     * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n     */\n    get draw() {\n        this.initialize();\n        return this._draw;\n    }\n    set draw(d) {\n        assert(!this._initialized, \"Draw cannot be set after initialization.\");\n        this._draw = d;\n    }\n    /**\n     * A reference to the Context's destination node.\n     */\n    get destination() {\n        this.initialize();\n        return this._destination;\n    }\n    set destination(d) {\n        assert(!this._initialized, \"The destination cannot be set after initialization.\");\n        this._destination = d;\n    }\n    /**\n     * Create an audio worklet node from a name and options. The module\n     * must first be loaded using [[addAudioWorkletModule]].\n     */\n    createAudioWorkletNode(name, options) {\n        return createAudioWorkletNode(this.rawContext, name, options);\n    }\n    /**\n     * Add an AudioWorkletProcessor module\n     * @param url The url of the module\n     * @param name The name of the module\n     */\n    addAudioWorkletModule(url, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n            if (!this._workletModules.has(name)) {\n                this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n            }\n            yield this._workletModules.get(name);\n        });\n    }\n    /**\n     * Returns a promise which resolves when all of the worklets have been loaded on this context\n     */\n    workletsAreReady() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const promises = [];\n            this._workletModules.forEach(promise => promises.push(promise));\n            yield Promise.all(promises);\n        });\n    }\n    //---------------------------\n    // TICKER\n    //---------------------------\n    /**\n     * How often the interval callback is invoked.\n     * This number corresponds to how responsive the scheduling\n     * can be. context.updateInterval + context.lookAhead gives you the\n     * total latency between scheduling an event and hearing it.\n     */\n    get updateInterval() {\n        return this._ticker.updateInterval;\n    }\n    set updateInterval(interval) {\n        this._ticker.updateInterval = interval;\n    }\n    /**\n     * What the source of the clock is, either \"worker\" (default),\n     * \"timeout\", or \"offline\" (none).\n     */\n    get clockSource() {\n        return this._ticker.type;\n    }\n    set clockSource(type) {\n        this._ticker.type = type;\n    }\n    /**\n     * The type of playback, which affects tradeoffs between audio\n     * output latency and responsiveness.\n     * In addition to setting the value in seconds, the latencyHint also\n     * accepts the strings \"interactive\" (prioritizes low latency),\n     * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n     * latency and performance).\n     * @example\n     * // prioritize sustained playback\n     * const context = new Tone.Context({ latencyHint: \"playback\" });\n     * // set this context as the global Context\n     * Tone.setContext(context);\n     * // the global context is gettable with Tone.getContext()\n     * console.log(Tone.getContext().latencyHint);\n     */\n    get latencyHint() {\n        return this._latencyHint;\n    }\n    /**\n     * Update the lookAhead and updateInterval based on the latencyHint\n     */\n    _setLatencyHint(hint) {\n        let lookAheadValue = 0;\n        this._latencyHint = hint;\n        if (isString(hint)) {\n            switch (hint) {\n                case \"interactive\":\n                    lookAheadValue = 0.1;\n                    break;\n                case \"playback\":\n                    lookAheadValue = 0.5;\n                    break;\n                case \"balanced\":\n                    lookAheadValue = 0.25;\n                    break;\n            }\n        }\n        this.lookAhead = lookAheadValue;\n        this.updateInterval = lookAheadValue / 2;\n    }\n    /**\n     * The unwrapped AudioContext or OfflineAudioContext\n     */\n    get rawContext() {\n        return this._context;\n    }\n    /**\n     * The current audio context time plus a short [[lookAhead]].\n     */\n    now() {\n        return this._context.currentTime + this.lookAhead;\n    }\n    /**\n     * The current audio context time without the [[lookAhead]].\n     * In most cases it is better to use [[now]] instead of [[immediate]] since\n     * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n     * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n     * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n     */\n    immediate() {\n        return this._context.currentTime;\n    }\n    /**\n     * Starts the audio context from a suspended state. This is required\n     * to initially start the AudioContext. See [[Tone.start]]\n     */\n    resume() {\n        if (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n            return this._context.resume();\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n    /**\n     * Close the context. Once closed, the context can no longer be used and\n     * any AudioNodes created from the context will be silent.\n     */\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (isAudioContext(this._context)) {\n                yield this._context.close();\n            }\n            if (this._initialized) {\n                closeContext(this);\n            }\n        });\n    }\n    /**\n     * **Internal** Generate a looped buffer at some constant value.\n     */\n    getConstant(val) {\n        if (this._constants.has(val)) {\n            return this._constants.get(val);\n        }\n        else {\n            const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n            const arr = buffer.getChannelData(0);\n            for (let i = 0; i < arr.length; i++) {\n                arr[i] = val;\n            }\n            const constant = this._context.createBufferSource();\n            constant.channelCount = 1;\n            constant.channelCountMode = \"explicit\";\n            constant.buffer = buffer;\n            constant.loop = true;\n            constant.start(0);\n            this._constants.set(val, constant);\n            return constant;\n        }\n    }\n    /**\n     * Clean up. Also closes the audio context.\n     */\n    dispose() {\n        super.dispose();\n        this._ticker.dispose();\n        this._timeouts.dispose();\n        Object.keys(this._constants).map(val => this._constants[val].disconnect());\n        return this;\n    }\n    //---------------------------\n    // TIMEOUTS\n    //---------------------------\n    /**\n     * The private loop which keeps track of the context scheduled timeouts\n     * Is invoked from the clock source\n     */\n    _timeoutLoop() {\n        const now = this.now();\n        let firstEvent = this._timeouts.peek();\n        while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n            // invoke the callback\n            firstEvent.callback();\n            // shift the first event off\n            this._timeouts.shift();\n            // get the next one\n            firstEvent = this._timeouts.peek();\n        }\n    }\n    /**\n     * A setTimeout which is guaranteed by the clock source.\n     * Also runs in the offline context.\n     * @param  fn       The callback to invoke\n     * @param  timeout  The timeout in seconds\n     * @returns ID to use when invoking Context.clearTimeout\n     */\n    setTimeout(fn, timeout) {\n        this._timeoutIds++;\n        const now = this.now();\n        this._timeouts.add({\n            callback: fn,\n            id: this._timeoutIds,\n            time: now + timeout,\n        });\n        return this._timeoutIds;\n    }\n    /**\n     * Clears a previously scheduled timeout with Tone.context.setTimeout\n     * @param  id  The ID returned from setTimeout\n     */\n    clearTimeout(id) {\n        this._timeouts.forEach(event => {\n            if (event.id === id) {\n                this._timeouts.remove(event);\n            }\n        });\n        return this;\n    }\n    /**\n     * Clear the function scheduled by [[setInterval]]\n     */\n    clearInterval(id) {\n        return this.clearTimeout(id);\n    }\n    /**\n     * Adds a repeating event to the context's callback clock\n     */\n    setInterval(fn, interval) {\n        const id = ++this._timeoutIds;\n        const intervalFn = () => {\n            const now = this.now();\n            this._timeouts.add({\n                callback: () => {\n                    // invoke the callback\n                    fn();\n                    // invoke the event to repeat it\n                    intervalFn();\n                },\n                id,\n                time: now + interval,\n            });\n        };\n        // kick it off\n        intervalFn();\n        return id;\n    }\n}\n//# sourceMappingURL=Context.js.map"]},"metadata":{},"sourceType":"module"}