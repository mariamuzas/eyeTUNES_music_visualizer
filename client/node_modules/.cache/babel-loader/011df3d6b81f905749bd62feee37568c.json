{"ast":null,"code":"import { ToneAudioWorklet } from \"../core/worklet/ToneAudioWorklet\";\nimport { Effect } from \"./Effect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { workletName } from \"./BitCrusher.worklet\";\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * // initialize crusher and route a synth through it\n * const crusher = new Tone.BitCrusher(4).toDestination();\n * const synth = new Tone.Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n *\n * @category Effect\n */\n\nexport class BitCrusher extends Effect {\n  constructor() {\n    super(optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]));\n    this.name = \"BitCrusher\";\n    const options = optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]);\n    this._bitCrusherWorklet = new BitCrusherWorklet({\n      context: this.context,\n      bits: options.bits\n    }); // connect it up\n\n    this.connectEffect(this._bitCrusherWorklet);\n    this.bits = this._bitCrusherWorklet.bits;\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      bits: 4\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._bitCrusherWorklet.dispose();\n\n    return this;\n  }\n\n}\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\n\nclass BitCrusherWorklet extends ToneAudioWorklet {\n  constructor() {\n    super(optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments));\n    this.name = \"BitCrusherWorklet\";\n    const options = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);\n    this.input = new Gain({\n      context: this.context\n    });\n    this.output = new Gain({\n      context: this.context\n    });\n    this.bits = new Param({\n      context: this.context,\n      value: options.bits,\n      units: \"positive\",\n      minValue: 1,\n      maxValue: 16,\n      param: this._dummyParam,\n      swappable: true\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioWorklet.getDefaults(), {\n      bits: 12\n    });\n  }\n\n  _audioWorkletName() {\n    return workletName;\n  }\n\n  onReady(node) {\n    connectSeries(this.input, node, this.output);\n    const bits = node.parameters.get(\"bits\");\n    this.bits.setParam(bits);\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.output.dispose();\n    this.bits.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../Tone/effect/BitCrusher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ToneAudioWorklet } from \"../core/worklet/ToneAudioWorklet\";\nimport { Effect } from \"./Effect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { workletName } from \"./BitCrusher.worklet\";\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * // initialize crusher and route a synth through it\n * const crusher = new Tone.BitCrusher(4).toDestination();\n * const synth = new Tone.Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n *\n * @category Effect\n */\nexport class BitCrusher extends Effect {\n    constructor() {\n        super(optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]));\n        this.name = \"BitCrusher\";\n        const options = optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]);\n        this._bitCrusherWorklet = new BitCrusherWorklet({\n            context: this.context,\n            bits: options.bits,\n        });\n        // connect it up\n        this.connectEffect(this._bitCrusherWorklet);\n        this.bits = this._bitCrusherWorklet.bits;\n    }\n    static getDefaults() {\n        return Object.assign(Effect.getDefaults(), {\n            bits: 4,\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._bitCrusherWorklet.dispose();\n        return this;\n    }\n}\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\nclass BitCrusherWorklet extends ToneAudioWorklet {\n    constructor() {\n        super(optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments));\n        this.name = \"BitCrusherWorklet\";\n        const options = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);\n        this.input = new Gain({ context: this.context });\n        this.output = new Gain({ context: this.context });\n        this.bits = new Param({\n            context: this.context,\n            value: options.bits,\n            units: \"positive\",\n            minValue: 1,\n            maxValue: 16,\n            param: this._dummyParam,\n            swappable: true,\n        });\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioWorklet.getDefaults(), {\n            bits: 12,\n        });\n    }\n    _audioWorkletName() {\n        return workletName;\n    }\n    onReady(node) {\n        connectSeries(this.input, node, this.output);\n        const bits = node.parameters.get(\"bits\");\n        this.bits.setParam(bits);\n    }\n    dispose() {\n        super.dispose();\n        this.input.dispose();\n        this.output.dispose();\n        this.bits.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=BitCrusher.js.map"]},"metadata":{},"sourceType":"module"}