{"ast":null,"code":"import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\n\nexport class TickSource extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n\n    this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n\n    this._tickOffset = new Timeline();\n    const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    this.frequency = new TickSignal({\n      context: this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\"); // set the initial state\n\n    this._state.setStateAtTime(\"stopped\", 0); // add the first event\n\n\n    this.setTicksAtTime(0, 0);\n  }\n\n  static getDefaults() {\n    return Object.assign({\n      frequency: 1,\n      units: \"hertz\"\n    }, ToneWithContext.getDefaults());\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n\n\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset The number of ticks to start the source at\n   */\n\n\n  start(time, offset) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      if (isDefined(offset)) {\n        this.setTicksAtTime(offset, computedTime);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   */\n\n\n  stop(time) {\n    const computedTime = this.toSeconds(time); // cancel the previous stop\n\n    if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n      const event = this._state.get(computedTime);\n\n      if (event && event.time > 0) {\n        this._tickOffset.cancel(event.time);\n\n        this._state.cancel(event.time);\n      }\n    }\n\n    this._state.cancel(computedTime);\n\n    this._state.setStateAtTime(\"stopped\", computedTime);\n\n    this.setTicksAtTime(0, computedTime);\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n\n\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n   * @param time When to clear the events after\n   */\n\n\n  cancel(time) {\n    time = this.toSeconds(time);\n\n    this._state.cancel(time);\n\n    this._tickOffset.cancel(time);\n\n    return this;\n  }\n  /**\n   * Get the elapsed ticks at the given time\n   * @param  time  When to get the tick value\n   * @return The number of ticks\n   */\n\n\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const stopEvent = this._state.getLastState(\"stopped\", computedTime); // this event allows forEachBetween to iterate until the current time\n\n\n    const tmpEvent = {\n      state: \"paused\",\n      time: computedTime\n    };\n\n    this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n    let lastState = stopEvent;\n    let elapsedTicks = 0; // iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n      let periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n      const offsetEvent = this._tickOffset.get(e.time);\n\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedTicks = offsetEvent.ticks;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n      }\n\n      lastState = e;\n    }); // remove the temporary event\n\n\n    this._state.remove(tmpEvent); // return the ticks\n\n\n    return elapsedTicks;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked. Returns -1 when stopped.\n   */\n\n\n  get ticks() {\n    return this.getTicksAtTime(this.now());\n  }\n\n  set ticks(t) {\n    this.setTicksAtTime(t, this.now());\n  }\n  /**\n   * The time since ticks=0 that the TickSource has been running. Accounts\n   * for tempo curves\n   */\n\n\n  get seconds() {\n    return this.getSecondsAtTime(this.now());\n  }\n\n  set seconds(s) {\n    const now = this.now();\n    const ticks = this.frequency.timeToTicks(s, now);\n    this.setTicksAtTime(ticks, now);\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    time = this.toSeconds(time);\n\n    const stopEvent = this._state.getLastState(\"stopped\", time); // this event allows forEachBetween to iterate until the current time\n\n\n    const tmpEvent = {\n      state: \"paused\",\n      time\n    };\n\n    this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n    let lastState = stopEvent;\n    let elapsedSeconds = 0; // iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n      let periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n      const offsetEvent = this._tickOffset.get(e.time);\n\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedSeconds = offsetEvent.seconds;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedSeconds += e.time - periodStartTime;\n      }\n\n      lastState = e;\n    }); // remove the temporary event\n\n\n    this._state.remove(tmpEvent); // return the ticks\n\n\n    return elapsedSeconds;\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n\n\n  setTicksAtTime(ticks, time) {\n    time = this.toSeconds(time);\n\n    this._tickOffset.cancel(time);\n\n    this._tickOffset.add({\n      seconds: this.frequency.getDurationOfTicks(ticks, time),\n      ticks,\n      time\n    });\n\n    return this;\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   */\n\n\n  getStateAtTime(time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n\n\n  getTimeOfTick(tick, before = this.now()) {\n    const offset = this._tickOffset.get(before);\n\n    const event = this._state.get(before);\n\n    const startTime = Math.max(offset.time, event.time);\n    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n    return this.frequency.getTimeOfTick(absoluteTicks);\n  }\n  /**\n   * Invoke the callback event at all scheduled ticks between the\n   * start time and the end time\n   * @param  startTime  The beginning of the search range\n   * @param  endTime    The end of the search range\n   * @param  callback   The callback to invoke with each tick\n   */\n\n\n  forEachTickBetween(startTime, endTime, callback) {\n    // only iterate through the sections where it is \"started\"\n    let lastStateEvent = this._state.get(startTime);\n\n    this._state.forEachBetween(startTime, endTime, event => {\n      if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n      }\n\n      lastStateEvent = event;\n    });\n\n    let error = null;\n\n    if (lastStateEvent && lastStateEvent.state === \"started\") {\n      const maxStartTime = Math.max(lastStateEvent.time, startTime); // figure out the difference between the frequency ticks and the\n\n      const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n      const diff = startTicks - ticksAtStart;\n      let offset = Math.ceil(diff) - diff; // guard against floating point issues\n\n      offset = EQ(offset, 1) ? 0 : offset;\n      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\n      while (nextTickTime < endTime) {\n        try {\n          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n        } catch (e) {\n          error = e;\n          break;\n        }\n\n        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n      }\n    }\n\n    if (error) {\n      throw error;\n    }\n\n    return this;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._state.dispose();\n\n    this._tickOffset.dispose();\n\n    this.frequency.dispose();\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/core/clock/TickSource.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n        this.name = \"TickSource\";\n        /**\n         * The state timeline\n         */\n        this._state = new StateTimeline();\n        /**\n         * The offset values of the ticks\n         */\n        this._tickOffset = new Timeline();\n        const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n        this.frequency = new TickSignal({\n            context: this.context,\n            units: options.units,\n            value: options.frequency,\n        });\n        readOnly(this, \"frequency\");\n        // set the initial state\n        this._state.setStateAtTime(\"stopped\", 0);\n        // add the first event\n        this.setTicksAtTime(0, 0);\n    }\n    static getDefaults() {\n        return Object.assign({\n            frequency: 1,\n            units: \"hertz\",\n        }, ToneWithContext.getDefaults());\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get state() {\n        return this.getStateAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset The number of ticks to start the source at\n     */\n    start(time, offset) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) !== \"started\") {\n            this._state.setStateAtTime(\"started\", computedTime);\n            if (isDefined(offset)) {\n                this.setTicksAtTime(offset, computedTime);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     */\n    stop(time) {\n        const computedTime = this.toSeconds(time);\n        // cancel the previous stop\n        if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n            const event = this._state.get(computedTime);\n            if (event && event.time > 0) {\n                this._tickOffset.cancel(event.time);\n                this._state.cancel(event.time);\n            }\n        }\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n        this.setTicksAtTime(0, computedTime);\n        return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n    pause(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            this._state.setStateAtTime(\"paused\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n     * @param time When to clear the events after\n     */\n    cancel(time) {\n        time = this.toSeconds(time);\n        this._state.cancel(time);\n        this._tickOffset.cancel(time);\n        return this;\n    }\n    /**\n     * Get the elapsed ticks at the given time\n     * @param  time  When to get the tick value\n     * @return The number of ticks\n     */\n    getTicksAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        const stopEvent = this._state.getLastState(\"stopped\", computedTime);\n        // this event allows forEachBetween to iterate until the current time\n        const tmpEvent = { state: \"paused\", time: computedTime };\n        this._state.add(tmpEvent);\n        // keep track of the previous offset event\n        let lastState = stopEvent;\n        let elapsedTicks = 0;\n        // iterate through all the events since the last stop\n        this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n            let periodStartTime = lastState.time;\n            // if there is an offset event in this period use that\n            const offsetEvent = this._tickOffset.get(e.time);\n            if (offsetEvent && offsetEvent.time >= lastState.time) {\n                elapsedTicks = offsetEvent.ticks;\n                periodStartTime = offsetEvent.time;\n            }\n            if (lastState.state === \"started\" && e.state !== \"started\") {\n                elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n            }\n            lastState = e;\n        });\n        // remove the temporary event\n        this._state.remove(tmpEvent);\n        // return the ticks\n        return elapsedTicks;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked. Returns -1 when stopped.\n     */\n    get ticks() {\n        return this.getTicksAtTime(this.now());\n    }\n    set ticks(t) {\n        this.setTicksAtTime(t, this.now());\n    }\n    /**\n     * The time since ticks=0 that the TickSource has been running. Accounts\n     * for tempo curves\n     */\n    get seconds() {\n        return this.getSecondsAtTime(this.now());\n    }\n    set seconds(s) {\n        const now = this.now();\n        const ticks = this.frequency.timeToTicks(s, now);\n        this.setTicksAtTime(ticks, now);\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        time = this.toSeconds(time);\n        const stopEvent = this._state.getLastState(\"stopped\", time);\n        // this event allows forEachBetween to iterate until the current time\n        const tmpEvent = { state: \"paused\", time };\n        this._state.add(tmpEvent);\n        // keep track of the previous offset event\n        let lastState = stopEvent;\n        let elapsedSeconds = 0;\n        // iterate through all the events since the last stop\n        this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n            let periodStartTime = lastState.time;\n            // if there is an offset event in this period use that\n            const offsetEvent = this._tickOffset.get(e.time);\n            if (offsetEvent && offsetEvent.time >= lastState.time) {\n                elapsedSeconds = offsetEvent.seconds;\n                periodStartTime = offsetEvent.time;\n            }\n            if (lastState.state === \"started\" && e.state !== \"started\") {\n                elapsedSeconds += e.time - periodStartTime;\n            }\n            lastState = e;\n        });\n        // remove the temporary event\n        this._state.remove(tmpEvent);\n        // return the ticks\n        return elapsedSeconds;\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n    setTicksAtTime(ticks, time) {\n        time = this.toSeconds(time);\n        this._tickOffset.cancel(time);\n        this._tickOffset.add({\n            seconds: this.frequency.getDurationOfTicks(ticks, time),\n            ticks,\n            time,\n        });\n        return this;\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     */\n    getStateAtTime(time) {\n        time = this.toSeconds(time);\n        return this._state.getValueAtTime(time);\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n    getTimeOfTick(tick, before = this.now()) {\n        const offset = this._tickOffset.get(before);\n        const event = this._state.get(before);\n        const startTime = Math.max(offset.time, event.time);\n        const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n        return this.frequency.getTimeOfTick(absoluteTicks);\n    }\n    /**\n     * Invoke the callback event at all scheduled ticks between the\n     * start time and the end time\n     * @param  startTime  The beginning of the search range\n     * @param  endTime    The end of the search range\n     * @param  callback   The callback to invoke with each tick\n     */\n    forEachTickBetween(startTime, endTime, callback) {\n        // only iterate through the sections where it is \"started\"\n        let lastStateEvent = this._state.get(startTime);\n        this._state.forEachBetween(startTime, endTime, event => {\n            if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n                this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n            }\n            lastStateEvent = event;\n        });\n        let error = null;\n        if (lastStateEvent && lastStateEvent.state === \"started\") {\n            const maxStartTime = Math.max(lastStateEvent.time, startTime);\n            // figure out the difference between the frequency ticks and the\n            const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n            const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n            const diff = startTicks - ticksAtStart;\n            let offset = Math.ceil(diff) - diff;\n            // guard against floating point issues\n            offset = EQ(offset, 1) ? 0 : offset;\n            let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n            while (nextTickTime < endTime) {\n                try {\n                    callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n                }\n                catch (e) {\n                    error = e;\n                    break;\n                }\n                nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n            }\n        }\n        if (error) {\n            throw error;\n        }\n        return this;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._state.dispose();\n        this._tickOffset.dispose();\n        this.frequency.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=TickSource.js.map"]},"metadata":{},"sourceType":"module"}