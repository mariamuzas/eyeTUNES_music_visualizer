{"ast":null,"code":"import { TicksClass } from \"../type/Ticks\";\nimport { TransportEvent } from \"./TransportEvent\";\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\n\nexport class TransportRepeatEvent extends TransportEvent {\n  /**\n   * @param transport The transport object which the event belongs to\n   */\n  constructor(transport, opts) {\n    super(transport, opts);\n    /**\n     * The ID of the current timeline event\n     */\n\n    this._currentId = -1;\n    /**\n     * The ID of the next timeline event\n     */\n\n    this._nextId = -1;\n    /**\n     * The time of the next event\n     */\n\n    this._nextTick = this.time;\n    /**\n     * a reference to the bound start method\n     */\n\n    this._boundRestart = this._restart.bind(this);\n    const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n    this.duration = new TicksClass(transport.context, options.duration).valueOf();\n    this._interval = new TicksClass(transport.context, options.interval).valueOf();\n    this._nextTick = options.time;\n    this.transport.on(\"start\", this._boundRestart);\n    this.transport.on(\"loopStart\", this._boundRestart);\n    this.context = this.transport.context;\n\n    this._restart();\n  }\n\n  static getDefaults() {\n    return Object.assign({}, TransportEvent.getDefaults(), {\n      duration: Infinity,\n      interval: 1,\n      once: false\n    });\n  }\n  /**\n   * Invoke the callback. Returns the tick time which\n   * the next event should be scheduled at.\n   * @param  time  The AudioContext time in seconds of the event\n   */\n\n\n  invoke(time) {\n    // create more events if necessary\n    this._createEvents(time); // call the super class\n\n\n    super.invoke(time);\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n\n\n  _createEvents(time) {\n    // schedule the next event\n    const ticks = this.transport.getTicksAtTime(time);\n\n    if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n      this._nextTick += this._interval;\n      this._currentId = this._nextId;\n      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    }\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n\n\n  _restart(time) {\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this._nextTick = this.time;\n    const ticks = this.transport.getTicksAtTime(time);\n\n    if (ticks > this.time) {\n      this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n    }\n\n    this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    this._nextTick += this._interval;\n    this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this.transport.off(\"start\", this._boundRestart);\n    this.transport.off(\"loopStart\", this._boundRestart);\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/core/clock/TransportRepeatEvent.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { TicksClass } from \"../type/Ticks\";\nimport { TransportEvent } from \"./TransportEvent\";\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n    /**\n     * @param transport The transport object which the event belongs to\n     */\n    constructor(transport, opts) {\n        super(transport, opts);\n        /**\n         * The ID of the current timeline event\n         */\n        this._currentId = -1;\n        /**\n         * The ID of the next timeline event\n         */\n        this._nextId = -1;\n        /**\n         * The time of the next event\n         */\n        this._nextTick = this.time;\n        /**\n         * a reference to the bound start method\n         */\n        this._boundRestart = this._restart.bind(this);\n        const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n        this.duration = new TicksClass(transport.context, options.duration).valueOf();\n        this._interval = new TicksClass(transport.context, options.interval).valueOf();\n        this._nextTick = options.time;\n        this.transport.on(\"start\", this._boundRestart);\n        this.transport.on(\"loopStart\", this._boundRestart);\n        this.context = this.transport.context;\n        this._restart();\n    }\n    static getDefaults() {\n        return Object.assign({}, TransportEvent.getDefaults(), {\n            duration: Infinity,\n            interval: 1,\n            once: false,\n        });\n    }\n    /**\n     * Invoke the callback. Returns the tick time which\n     * the next event should be scheduled at.\n     * @param  time  The AudioContext time in seconds of the event\n     */\n    invoke(time) {\n        // create more events if necessary\n        this._createEvents(time);\n        // call the super class\n        super.invoke(time);\n    }\n    /**\n     * Push more events onto the timeline to keep up with the position of the timeline\n     */\n    _createEvents(time) {\n        // schedule the next event\n        const ticks = this.transport.getTicksAtTime(time);\n        if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n            this._nextTick += this._interval;\n            this._currentId = this._nextId;\n            this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n        }\n    }\n    /**\n     * Push more events onto the timeline to keep up with the position of the timeline\n     */\n    _restart(time) {\n        this.transport.clear(this._currentId);\n        this.transport.clear(this._nextId);\n        this._nextTick = this.time;\n        const ticks = this.transport.getTicksAtTime(time);\n        if (ticks > this.time) {\n            this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n        }\n        this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n        this._nextTick += this._interval;\n        this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this.transport.clear(this._currentId);\n        this.transport.clear(this._nextId);\n        this.transport.off(\"start\", this._boundRestart);\n        this.transport.off(\"loopStart\", this._boundRestart);\n        return this;\n    }\n}\n//# sourceMappingURL=TransportRepeatEvent.js.map"]},"metadata":{},"sourceType":"module"}