{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @example\n * return Tone.Offline(() => {\n * \tconst pwm = new Tone.PWMOscillator(60, 0.3).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\n\nexport class PWMOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n    this.name = \"PWMOscillator\";\n    this.sourceType = \"pwm\";\n    /**\n     * Scale the oscillator so it doesn't go silent\n     * at the extreme values.\n     */\n\n    this._scale = new Multiply({\n      context: this.context,\n      value: 2\n    });\n    const options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n    this._pulse = new PulseOscillator({\n      context: this.context,\n      frequency: options.modulationFrequency\n    }); // change the pulse oscillator type\n\n    this._pulse.carrierType = \"sine\";\n    this.modulationFrequency = this._pulse.frequency;\n    this._modulator = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: options.frequency,\n      onstop: () => this.onstop(this),\n      phase: options.phase\n    });\n    this.frequency = this._modulator.frequency;\n    this.detune = this._modulator.detune; // connections\n\n    this._modulator.chain(this._scale, this._pulse.width);\n\n    this._pulse.connect(this.output);\n\n    readOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      modulationFrequency: 0.4,\n      phase: 0,\n      type: \"pwm\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    time = this.toSeconds(time);\n\n    this._modulator.start(time);\n\n    this._pulse.start(time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    time = this.toSeconds(time);\n\n    this._modulator.stop(time);\n\n    this._pulse.stop(time);\n  }\n  /**\n   * restart the oscillator\n   */\n\n\n  _restart(time) {\n    this._modulator.restart(time);\n\n    this._pulse.restart(time);\n  }\n  /**\n   * The type of the oscillator. Always returns \"pwm\".\n   */\n\n\n  get type() {\n    return \"pwm\";\n  }\n  /**\n   * The baseType of the oscillator. Always returns \"pwm\".\n   */\n\n\n  get baseType() {\n    return \"pwm\";\n  }\n  /**\n   * The partials of the waveform. Cannot set partials for this waveform type\n   */\n\n\n  get partials() {\n    return [];\n  }\n  /**\n   * No partials for this waveform type.\n   */\n\n\n  get partialCount() {\n    return 0;\n  }\n  /**\n   * The phase of the oscillator in degrees.\n   */\n\n\n  get phase() {\n    return this._modulator.phase;\n  }\n\n  set phase(phase) {\n    this._modulator.phase = phase;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._pulse.dispose();\n\n    this._scale.dispose();\n\n    this._modulator.dispose();\n\n    return this;\n  }\n\n}","map":{"version":3,"sources":["../../../../Tone/source/oscillator/PWMOscillator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @example\n * return Tone.Offline(() => {\n * \tconst pwm = new Tone.PWMOscillator(60, 0.3).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class PWMOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n        this.name = \"PWMOscillator\";\n        this.sourceType = \"pwm\";\n        /**\n         * Scale the oscillator so it doesn't go silent\n         * at the extreme values.\n         */\n        this._scale = new Multiply({\n            context: this.context,\n            value: 2,\n        });\n        const options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n        this._pulse = new PulseOscillator({\n            context: this.context,\n            frequency: options.modulationFrequency,\n        });\n        // change the pulse oscillator type\n        this._pulse.carrierType = \"sine\";\n        this.modulationFrequency = this._pulse.frequency;\n        this._modulator = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: options.frequency,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n        });\n        this.frequency = this._modulator.frequency;\n        this.detune = this._modulator.detune;\n        // connections\n        this._modulator.chain(this._scale, this._pulse.width);\n        this._pulse.connect(this.output);\n        readOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            modulationFrequency: 0.4,\n            phase: 0,\n            type: \"pwm\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        time = this.toSeconds(time);\n        this._modulator.start(time);\n        this._pulse.start(time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        time = this.toSeconds(time);\n        this._modulator.stop(time);\n        this._pulse.stop(time);\n    }\n    /**\n     * restart the oscillator\n     */\n    _restart(time) {\n        this._modulator.restart(time);\n        this._pulse.restart(time);\n    }\n    /**\n     * The type of the oscillator. Always returns \"pwm\".\n     */\n    get type() {\n        return \"pwm\";\n    }\n    /**\n     * The baseType of the oscillator. Always returns \"pwm\".\n     */\n    get baseType() {\n        return \"pwm\";\n    }\n    /**\n     * The partials of the waveform. Cannot set partials for this waveform type\n     */\n    get partials() {\n        return [];\n    }\n    /**\n     * No partials for this waveform type.\n     */\n    get partialCount() {\n        return 0;\n    }\n    /**\n     * The phase of the oscillator in degrees.\n     */\n    get phase() {\n        return this._modulator.phase;\n    }\n    set phase(phase) {\n        this._modulator.phase = phase;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._pulse.dispose();\n        this._scale.dispose();\n        this._modulator.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=PWMOscillator.js.map"]},"metadata":{},"sourceType":"module"}